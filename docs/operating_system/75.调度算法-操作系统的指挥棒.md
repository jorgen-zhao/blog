---
title: 调度算法-操作系统的指挥棒
date: 2023-11-15 14:30:00
categories: 
  - operating_system
tags:
  - 操作系统
  - 调度算法
  - CPU管理
  - 进程调度
author: 
  name: Jorgen
  link: https://github.com/jorgen-zhao
---

## 前言

在操作系统的世界里，CPU就像一个忙碌的厨师，而进程则是等待处理的订单。如果没有一个好的"点餐系统"，厨房就会陷入混乱，订单积压，顾客抱怨。🍳➡️🍔 这个"点餐系统"就是我们要探讨的**调度算法**！

在我之前写的[进程与线程-操作系统的核心调度单元](/pages/17)中，我们已经了解了进程和线程的基本概念。但今天，我想深入探讨操作系统如何决定哪个进程应该获得CPU的使用权，以及这些决策背后的算法原理。

::: tip
调度算法是操作系统的核心组件之一，它直接影响系统的性能、响应时间和公平性。
:::

## 为什么调度算法如此重要？

想象一下，如果没有调度算法，CPU会怎样？它可能会一直执行一个进程，而其他进程则永远无法运行，这就是所谓的"饥饿"现象。😵 或者，CPU可能会在进程之间频繁切换，导致系统效率低下。

调度算法的目标是：

1. **CPU利用率最大化** - 让CPU尽可能忙碌
2. **系统吞吐量最大化** - 在单位时间内完成尽可能多的进程
3. **周转时间最小化** - 从进程提交到完成的时间尽可能短
4. **等待时间最小化** - 进程在就绪队列中等待的时间尽可能短
5. **响应时间最小化** - 从用户提交请求到首次响应的时间尽可能短

## 调度算法的分类

调度算法主要可以分为两大类：**非抢占式调度**和**抢占式调度**。

### 非抢占式调度

在非抢占式调度中，一旦CPU分配给一个进程，该进程会一直使用CPU，直到它完成或自愿放弃CPU控制权。

::: theorem
非抢占式调度的特点：
- 简单实现
- 不会出现上下文切换的开销
- 可能导致短进程等待长进程完成
:::

常见的非抢占式调度算法包括：

#### 先来先服务（FCFS）

FCFS是最简单的调度算法，按照进程到达的顺序进行调度。

```mermaid
gantt
    title FCFS调度示例
    dateFormat  X
    axisFormat %s
    
    section 进程
    进程A ：a1, 0, 5
    进程B ：a2, 5, 3
    进程C ：a3, 8, 4
```

FCFS的优点是简单公平，缺点是可能导致"护航效应"——短进程可能被长进程阻塞。

#### 最短作业优先（SJF）

SJF算法优先执行预计运行时间最短的进程。

```mermaid
gantt
    title SJF调度示例
    dateFormat  X
    axisFormat %s
    
    section 进程
    进程B ：a1, 0, 3
    进程C ：a2, 3, 4
    进程A ：a3, 7, 5
```

SJF可以最小化平均等待时间，但需要预知进程的运行时间，且可能导致长进程"饥饿"。

### 抢占式调度

在抢占式调度中，操作系统可以强制剥夺当前进程的CPU使用权，并将其分配给另一个更重要的进程。

::: theorem
抢占式调度的特点：
- 更好的响应性
- 防止长进程垄断CPU
- 需要更复杂的实现和上下文切换机制
:::

#### 最短剩余时间优先（SRTF）

SRTF是SJF的抢占式版本，如果新进程的剩余时间比当前进程的剩余时间短，则抢占当前进程。

#### 优先级调度

为每个进程分配一个优先级，调度器总是选择优先级最高的进程运行。

```mermaid
gantt
    title 优先级调度示例
    dateFormat  X
    axisFormat %s
    
    section 进程
    高优先级进程 ：a1, 0, 3
    低优先级进程 ：a2, 0, 6
    中优先级进程 ：a3, 3, 4
```

优先级调度可以确保重要任务优先执行，但需要仔细设计优先级分配机制，防止低优先级进程"饥饿"。

#### 轮转调度（RR）

轮转调度将CPU时间划分为固定大小的"时间片"，每个进程轮流获得一个时间片。

```mermaid
gantt
    title 轮转调度示例 (时间片=2)
    dateFormat  X
    axisFormat %s
    
    section 进程
    进程A ：a1, 0, 2
    进程B ：a2, 2, 2
    进程C ：a3, 4, 2
    进程A ：a4, 6, 3
    进程B ：a5, 9, 1
```

轮转调度保证了公平性，适合分时系统，但时间片大小的选择对性能影响很大。

#### 多级队列调度

将进程分为不同优先级的队列，每个队列有自己的调度算法。

#### 多级反馈队列调度

这是最通用的一种调度算法，允许进程在队列之间移动，根据进程的行为动态调整其优先级。

## 现代操作系统中的调度实践

现代操作系统通常采用复杂的混合调度策略：

- Linux Completely Fair Scheduler (CFS)：使用红黑树实现虚拟运行时间跟踪，确保公平性
- Windows调度器：基于优先级的32级调度，结合多处理器亲和性
- macOS调度器：混合了优先级和公平性的调度算法

::: right
"调度算法没有最好的，只有最适合特定场景的。"
:::

## 个人建议

作为开发者，了解调度算法有助于我们：

1. 编写更高效的代码，减少不必要的CPU占用
2. 理解系统性能问题的根源
3. 在实时系统中正确设置进程优先级
4. 避免编写会导致"优先级反转"的代码

如果你对调度算法感兴趣，我建议你：

- 尝试实现一个简单的调度器模拟程序
- 使用`strace`或`perf`等工具观察进程调度行为
- 阅读Linux内核源码中的CFS实现

## 结语

调度算法是操作系统的"指挥棒"，它决定了各个进程如何共享宝贵的CPU资源。从简单的FCFS到复杂的CFS，调度算法的演进反映了计算机系统从批处理到分时系统，再到实时系统的演变。

> 虽然调度算法的设计充满挑战，但正是这些精巧的算法，让我们的计算机能够同时处理多个任务，为用户提供流畅的体验。

在下一篇文章中，我们将探讨另一个操作系统的重要主题——**死锁**，看看当进程互相等待资源时，操作系统如何应对这种"僵局"。

---

希望这篇文章能帮助你更好地理解操作系统中的调度算法！如果你有任何问题或建议，欢迎在评论区留言讨论。👇