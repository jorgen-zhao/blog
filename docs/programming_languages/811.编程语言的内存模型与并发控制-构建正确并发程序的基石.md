---
title: ç¼–ç¨‹è¯­è¨€çš„å†…å­˜æ¨¡å‹ä¸å¹¶å‘æ§åˆ¶ - æ„å»ºæ­£ç¡®å¹¶å‘ç¨‹åºçš„åŸºçŸ³
date: 2026-02-04
tags: [å¹¶å‘ç¼–ç¨‹, å†…å­˜æ¨¡å‹, å¹¶å‘æ§åˆ¶]
---

## å‰è¨€

åœ¨å½“ä»Šå¤šæ ¸å¤„ç†å™¨ç››è¡Œçš„æ—¶ä»£ï¼Œå¹¶å‘ç¼–ç¨‹å·²æˆä¸ºè½¯ä»¶å¼€å‘çš„æ ¸å¿ƒèƒ½åŠ›ã€‚ç„¶è€Œï¼Œç¼–å†™æ­£ç¡®çš„å¹¶å‘ç¨‹åºè¿œæ¯”æƒ³è±¡ä¸­å¤æ‚ã€‚ğŸ¤” å¾ˆå¤šå¼€å‘è€…éƒ½æ›¾é‡åˆ°è¿‡é‚£äº›åªåœ¨ç‰¹å®šæ¡ä»¶ä¸‹æ‰å‡ºç°çš„è¯¡å¼‚bugï¼Œè¿™äº›bugå¾€å¾€ä¸å†…å­˜æ¨¡å‹å’Œå¹¶å‘æ§åˆ¶æœºåˆ¶å¯†åˆ‡ç›¸å…³ã€‚

ä»Šå¤©ï¼Œæˆ‘æƒ³å’Œå¤§å®¶æ·±å…¥æ¢è®¨ä¸€ä¸ªå¸¸å¸¸è¢«å¿½è§†ä½†è‡³å…³é‡è¦çš„ä¸»é¢˜ï¼š**ç¼–ç¨‹è¯­è¨€çš„å†…å­˜æ¨¡å‹ä¸å¹¶å‘æ§åˆ¶æœºåˆ¶**ã€‚ç†è§£è¿™äº›æ¦‚å¿µï¼Œå°†å¸®åŠ©æˆ‘ä»¬æ„å»ºæ›´åŠ å¯é ã€é«˜æ•ˆçš„å¹¶å‘ç¨‹åºã€‚

## å†…å­˜æ¨¡å‹ï¼šå¹¶å‘ç¼–ç¨‹çš„åŸºçŸ³

### ä»€ä¹ˆæ˜¯å†…å­˜æ¨¡å‹ï¼Ÿ

å†…å­˜æ¨¡å‹å®šä¹‰äº†ç¨‹åºä¸­å˜é‡çš„è¯»å†™è¡Œä¸ºï¼Œç‰¹åˆ«æ˜¯åœ¨å¹¶å‘ç¯å¢ƒä¸‹ã€‚å®ƒå›ç­”äº†ä»¥ä¸‹å…³é”®é—®é¢˜ï¼š

- å½“ä¸€ä¸ªçº¿ç¨‹ä¿®æ”¹äº†ä¸€ä¸ªå˜é‡ï¼Œå…¶ä»–çº¿ç¨‹ä½•æ—¶èƒ½çœ‹åˆ°è¿™ä¸ªä¿®æ”¹ï¼Ÿ
- å¯¹ä¸åŒå˜é‡çš„è¯»å†™æ“ä½œå¯èƒ½ä¼šè¢«é‡æ’åºå—ï¼Ÿ
- ä»€ä¹ˆæ“ä½œæ˜¯åŸå­çš„ï¼Ÿ

::: tip
å†…å­˜æ¨¡å‹å°±åƒæ˜¯å¹¶å‘ç¼–ç¨‹çš„"å®ªæ³•"ï¼Œå®ƒè§„å®šäº†å¹¶å‘ç¨‹åºçš„è¡Œä¸ºè¾¹ç•Œå’Œä¿è¯ã€‚
:::

### ä¸»æµè¯­è¨€çš„å†…å­˜æ¨¡å‹

#### Javaå†…å­˜æ¨¡å‹

Javaå†…å­˜æ¨¡å‹(JMM)æ˜¯Javaå¹¶å‘ç¼–ç¨‹çš„åŸºç¡€ï¼Œå®ƒå®šä¹‰äº†çº¿ç¨‹é—´å¦‚ä½•é€šè¿‡å†…å­˜è¿›è¡Œäº¤äº’ã€‚JMMä¸»è¦åŒ…å«ä»¥ä¸‹ç‰¹æ€§ï¼š

- **åŸå­æ€§**ï¼šåŸºæœ¬ç±»å‹(long/doubleé™¤å¤–)çš„è¯»å†™æ˜¯åŸå­çš„ã€‚
- **å¯è§æ€§**ï¼šä¸€ä¸ªçº¿ç¨‹å¯¹å˜é‡çš„ä¿®æ”¹å¯¹å…¶ä»–çº¿ç¨‹æ˜¯å¯è§çš„ã€‚
- **æœ‰åºæ€§**ï¼šç¦æ­¢æŒ‡ä»¤é‡æ’åºã€‚

```java
// Javaä¸­çš„volatileå…³é”®å­—ä¿è¯äº†å¯è§æ€§å’Œä¸€å®šçš„æœ‰åºæ€§
private volatile boolean flag;

public void writer() {
    flag = true; // å¯¹flagçš„ä¿®æ”¹å¯¹å…¶ä»–çº¿ç¨‹ç«‹å³å¯è§
}

public void reader() {
    if (flag) { // èƒ½çœ‹åˆ°writerçº¿ç¨‹å¯¹flagçš„ä¿®æ”¹
        // do something
    }
}
```

#### C++å†…å­˜æ¨¡å‹

C++11å¼•å…¥äº†å†…å­˜æ¨¡å‹ï¼Œå®ƒæ¯”Javaæ›´åŠ å¤æ‚ä½†ä¹Ÿæ›´çµæ´»ï¼š

```cpp
// C++11ä¸­çš„atomicæ“ä½œ
std::atomic<bool> flag(false);

void writer() {
    flag.store(true, std::memory_order_release); // é‡Šæ”¾è¯­ä¹‰
}

void reader() {
    if (flag.load(std::memory_order_acquire)) { // è·å–è¯­ä¹‰
        // do something
    }
}
```

#### Goå†…å­˜æ¨¡å‹

Goè¯­è¨€çš„å†…å­˜æ¨¡å‹ç›¸å¯¹ç®€å•ï¼Œä¸»è¦åŸºäºHappens-BeforeåŸåˆ™ï¼š

```go
var done bool

func worker() {
    // do something
    done = true // è®¾ç½®doneæ ‡å¿—
}

func main() {
    go worker()
    for !done {
        // ç­‰å¾…workerå®Œæˆ
    }
    // workerçš„ä¿®æ”¹å¯¹mainå¯è§
}
```

## å¹¶å‘æ§åˆ¶æœºåˆ¶

### äº’æ–¥é”

äº’æ–¥é”æ˜¯æœ€åŸºæœ¬çš„å¹¶å‘æ§åˆ¶æœºåˆ¶ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®å…±äº«èµ„æºã€‚

#### Javaä¸­çš„äº’æ–¥é”

```java
private final Object lock = new Object();

public void criticalSection() {
    synchronized (lock) {
        // ä¸´ç•ŒåŒºä»£ç 
    }
}
```

#### Goä¸­çš„äº’æ–¥é”

```go
var mu sync.Mutex

func criticalSection() {
    mu.Lock()
    defer mu.Unlock()
    // ä¸´ç•ŒåŒºä»£ç 
}
```

#### Rustä¸­çš„äº’æ–¥é”

```rust
use std::sync::Mutex;

let data = Mutex::new(5);

{
    let mut num = data.lock().unwrap();
    *num = 6;
} // é”åœ¨è¿™é‡Œè‡ªåŠ¨é‡Šæ”¾
```

### ä¿¡å·é‡ä¸æ¡ä»¶å˜é‡

ä¿¡å·é‡å’Œæ¡ä»¶å˜é‡æä¾›äº†æ›´çµæ´»çš„å¹¶å‘æ§åˆ¶æ–¹å¼ã€‚

#### Javaä¸­çš„ä¿¡å·é‡å’Œæ¡ä»¶å˜é‡

```java
// ä¿¡å·é‡
Semaphore semaphore = new Semaphore(3);

// æ¡ä»¶å˜é‡
final Condition condition = lock.newCondition();

public void awaitCondition() throws InterruptedException {
    lock.lock();
    try {
        while (!conditionMet) {
            condition.await(); // ç­‰å¾…æ¡ä»¶æ»¡è¶³
        }
    } finally {
        lock.unlock();
    }
}
```

#### Goä¸­çš„é€šé“ä¸æ¡ä»¶åŒæ­¥

Goæ²¡æœ‰ä¼ ç»Ÿçš„æ¡ä»¶å˜é‡ï¼Œä½†é€šé“æä¾›äº†æ›´å¼ºå¤§çš„åŒæ­¥èƒ½åŠ›ï¼š

```go
// ä½¿ç”¨é€šé“å®ç°æ¡ä»¶åŒæ­¥
ch := make(chan struct{})

func worker() {
    // do work
    ch <- struct{}{} // å‘é€ä¿¡å·
}

func main() {
    go worker()
    <-ch // ç­‰å¾…ä¿¡å·
}
```

### åŸå­æ“ä½œ

åŸå­æ“ä½œæ˜¯ä¸å¯ä¸­æ–­çš„æ“ä½œï¼Œæä¾›äº†æ¯”é”æ›´è½»é‡çº§çš„å¹¶å‘æ§åˆ¶ã€‚

#### Javaä¸­çš„åŸå­æ“ä½œ

```java
AtomicInteger counter = new AtomicInteger(0);

// åŸå­é€’å¢
counter.incrementAndGet();

// åŸå­æ¯”è¾ƒå¹¶äº¤æ¢
counter.compareAndSet(expected, newValue);
```

#### C++ä¸­çš„åŸå­æ“ä½œ

```cpp
std::atomic<int> counter(0);

// åŸå­é€’å¢
counter.fetch_add(1);

// åŸå­æ¯”è¾ƒå¹¶äº¤æ¢
counter.compare_exchange_strong(expected, newValue);
```

#### Goä¸­çš„åŸå­æ“ä½œ

```go
var counter int64

// åŸå­é€’å¢
atomic.AddInt64(&counter, 1)

// åŸå­æ¯”è¾ƒå¹¶äº¤æ¢
atomic.CompareAndSwapInt64(&counter, old, new)
```

## å†…å­˜æ¨¡å‹ä¸å¹¶å‘æ§åˆ¶çš„å®è·µæŒ‘æˆ˜

### é‡æ’åºä¸å†…å­˜å±éšœ

ç°ä»£ç¼–è¯‘å™¨å’Œå¤„ç†å™¨ä¸ºäº†ä¼˜åŒ–æ€§èƒ½ï¼Œå¯èƒ½ä¼šå¯¹æŒ‡ä»¤è¿›è¡Œé‡æ’åºï¼Œè¿™å¯èƒ½å¯¼è‡´å¹¶å‘ç¨‹åºå‡ºç°æ„å¤–è¡Œä¸ºã€‚

```java
// é—®é¢˜ç¤ºä¾‹
class ReorderingExample {
    private int x = 0, y = 0;
    private boolean flag = false;

    public void writer() {
        x = 1; // å¯èƒ½è¢«é‡æ’åº
        flag = true; // å¯èƒ½è¢«é‡æ’åº
    }

    public void reader() {
        if (flag) {
            int r1 = y; // å¯èƒ½è¯»åˆ°0
            int r2 = x; // å¯èƒ½è¯»åˆ°1
        }
    }
}
```

è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨é€‚å½“çš„å†…å­˜å±éšœæˆ–åŒæ­¥åŸè¯­ï¼š

```java
// ä½¿ç”¨volatileé˜²æ­¢é‡æ’åº
private volatile boolean flag;

// æˆ–ä½¿ç”¨synchronizedå—
public void writer() {
    synchronized (this) {
        x = 1;
        flag = true;
    }
}
```

### ç¼“å­˜ä¸€è‡´æ€§ä¸å†…å­˜å¯è§æ€§

åœ¨å¤šæ ¸ç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªæ ¸å¿ƒéƒ½æœ‰è‡ªå·±çš„ç¼“å­˜ï¼Œè¿™å¯èƒ½å¯¼è‡´å†…å­˜å¯è§æ€§é—®é¢˜ã€‚

```java
// é—®é¢˜ç¤ºä¾‹
class VisibilityExample {
    private boolean ready = false;
    private int number = 0;

    public void writer() {
        number = 42;
        ready = true;
    }

    public void reader() {
        if (ready) {
            int r = number; // å¯èƒ½è¯»åˆ°0è€Œä¸æ˜¯42
            System.out.println(r);
        }
    }
}
```

è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨volatileæˆ–é€‚å½“çš„åŒæ­¥ï¼š

```java
// ä½¿ç”¨volatileä¿è¯å¯è§æ€§
private volatile boolean ready;

// æˆ–ä½¿ç”¨AtomicReference
private final AtomicReference<Boolean> ready = new AtomicReference<>(false);
```

### æ­»é”ä¸æ´»é”

ä¸å½“çš„é”ä½¿ç”¨å¯èƒ½å¯¼è‡´æ­»é”æˆ–æ´»é”ï¼š

```java
// æ­»é”ç¤ºä¾‹
class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized (lock1) {
            synchronized (lock2) {
                // do something
            }
        }
    }

    public void method2() {
        synchronized (lock2) {
            synchronized (lock1) {
                // do something
            }
        }
    }
}
```

è§£å†³æ–¹æ¡ˆæ˜¯é¿å…åµŒå¥—é”æˆ–ä½¿ç”¨é”æ’åºï¼š

```java
// ä½¿ç”¨é”é¡ºåºé¿å…æ­»é”
public void method1() {
    synchronized (lock1) {
        synchronized (lock2) {
            // do something
        }
    }
}

public void method2() {
    synchronized (lock1) { // ä¿æŒç›¸åŒçš„é”é¡ºåº
        synchronized (lock2) {
            // do something
        }
    }
}
```

## ä¸åŒè¯­è¨€çš„å†…å­˜æ¨¡å‹æ¯”è¾ƒ

### Java vs C++ vs Go

| ç‰¹æ€§ | Java | C++ | Go |
|------|------|-----|----|
| å†…å­˜æ¨¡å‹ | å¼ºå®šä¹‰ï¼ŒåŸºäº happens-before | çµæ´»ï¼Œæ”¯æŒå¤šç§å†…å­˜é¡ºåº | ç®€å•ï¼ŒåŸºäº happens-before |
| åŸå­æ“ä½œ | java.util.concurrent.atomic | std::atomic | sync/atomic åŒ… |
| é”æœºåˆ¶ | synchronized, ReentrantLock | std::mutex, std::lock | sync.Mutex |
| æ— é”æ•°æ®ç»“æ„ | java.util.concurrent.atomic | std::atomic | sync/atomic åŒ… |
| å†…å­˜å±éšœ | volatile, final, happens-before | memory_order æšä¸¾ | channel, sync åŒ… |

### Rustçš„å†…å­˜æ¨¡å‹

Rustçš„å†…å­˜æ¨¡å‹éå¸¸ç‹¬ç‰¹ï¼Œå®ƒé€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿå’Œç±»å‹ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶å°±é¿å…äº†å¤§é‡å¹¶å‘é—®é¢˜ï¼š

```rust
// Rustçš„æ‰€æœ‰æƒç³»ç»Ÿå¤©ç„¶é˜²æ­¢æ•°æ®ç«äº‰
use std::thread;

fn main() {
    let mut data = vec![1, 2, 3];
    
    // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½åŒæ—¶å€Ÿç”¨å¯å˜å’Œä¸å¯å˜å¼•ç”¨
    // let handle = thread::spawn(|| {
    //     println!("Data: {:?}", data);
    // });
    // data.push(4);
    // handle.join().unwrap();
    
    // æ­£ç¡®åšæ³•ï¼šä½¿ç”¨Arcå’ŒMutex
    let data = std::sync::Arc::new(std::sync::Mutex::new(vec![1, 2, 3]));
    let data_clone = data.clone();
    
    let handle = thread::spawn(move || {
        let mut data = data_clone.lock().unwrap();
        data.push(4);
    });
    
    let mut data = data.lock().unwrap();
    data.push(5);
    handle.join().unwrap();
    
    println!("Data: {:?}", data);
}
```

## æœ€ä½³å®è·µ

### 1. ä¼˜å…ˆä½¿ç”¨é«˜çº§å¹¶å‘æŠ½è±¡

```java
// ä¸æ¨èï¼šæ‰‹åŠ¨å®ç°åŒæ­¥
class Counter {
    private int value = 0;
    private final Object lock = new Object();
    
    public void increment() {
        synchronized (lock) {
            value++;
        }
    }
}

// æ¨èï¼šä½¿ç”¨é«˜çº§å¹¶å‘ç±»
class Counter {
    private final AtomicInteger value = new AtomicInteger(0);
    
    public void increment() {
        value.incrementAndGet();
    }
}
```

### 2. å°½é‡å‡å°‘é”çš„ç²’åº¦

```java
// ä¸æ¨èï¼šå¤§ç²’åº¦é”
class BigLockExample {
    private final Object lock = new Object();
    private List<String> list1 = new ArrayList<>();
    private List<String> list2 = new ArrayList<>();
    
    public void addToList1(String item) {
        synchronized (lock) {
            list1.add(item);
        }
    }
    
    public void addToList2(String item) {
        synchronized (lock) {
            list2.add(item);
        }
    }
}

// æ¨èï¼šç»†ç²’åº¦é”
class FineLockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    private List<String> list1 = new ArrayList<>();
    private List<String> list2 = new ArrayList<>();
    
    public void addToList1(String item) {
        synchronized (lock1) {
            list1.add(item);
        }
    }
    
    public void addToList2(String item) {
        synchronized (lock2) {
            list2.add(item);
        }
    }
}
```

### 3. é¿å…å¯å˜å…±äº«çŠ¶æ€

```go
// ä¸æ¨èï¼šå…±äº«å¯å˜çŠ¶æ€
type Counter struct {
    value int
    mu    sync.Mutex
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

// æ¨èï¼šä½¿ç”¨ä¸å¯å˜çŠ¶æ€æˆ–é€šé“
type Counter struct {
    ch chan int
}

func NewCounter() *Counter {
    c := &Counter{
        ch: make(chan int, 1),
    }
    c.ch <- 0
    return c
}

func (c *Counter) Increment() {
    current := <-c.ch
    c.ch <- current + 1
}

func (c *Counter) Value() int {
    return <-c.ch
}
```

### 4. ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„é›†åˆ

```java
// ä¸æ¨èï¼šæ‰‹åŠ¨åŒæ­¥é›†åˆ
List<String> list = Collections.synchronizedList(new ArrayList<>());

// æ¨èï¼šä½¿ç”¨å¹¶å‘é›†åˆ
List<String> list = new CopyOnWriteArrayList<>();
Map<String, String> map = new ConcurrentHashMap<>();
Set<String> set = ConcurrentHashMap.newKeySet();
```

## æœªæ¥è¶‹åŠ¿

### 1. æ›´é«˜çº§çš„å¹¶å‘æŠ½è±¡

éšç€ç¼–ç¨‹è¯­è¨€çš„å‘å±•ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¶Šæ¥è¶Šå¤šé«˜çº§å¹¶å‘æŠ½è±¡çš„å‡ºç°ï¼Œå¦‚ï¼š

- Goçš„goroutineå’Œchannel
- Rustçš„async/await
- Javaçš„CompletableFutureå’ŒStream API
- Kotlinçš„åç¨‹

### 2. åŸºäºç±»å‹çš„å¹¶å‘å®‰å…¨

ä¸€äº›ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚Rustï¼‰é€šè¿‡ç±»å‹ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶å°±ä¿è¯äº†å¹¶å‘å®‰å…¨ï¼Œå‡å°‘äº†è¿è¡Œæ—¶é”™è¯¯ã€‚

### 3. æ— é”æ•°æ®ç»“æ„çš„æ™®åŠ

éšç€ç¡¬ä»¶çš„å‘å±•ï¼Œæ— é”æ•°æ®ç»“æ„å˜å¾—è¶Šæ¥è¶Šé‡è¦ï¼Œå®ƒä»¬æä¾›äº†æ›´å¥½çš„æ€§èƒ½å’Œå¯æ‰©å±•æ€§ã€‚

### 4. å¹¶å‘ç¼–ç¨‹çš„è‡ªåŠ¨åŒ–å·¥å…·

é™æ€åˆ†æå’ŒåŠ¨æ€æµ‹è¯•å·¥å…·çš„å‘å±•ï¼Œä½¿å¾—å¹¶å‘ç¼–ç¨‹é”™è¯¯çš„æ£€æµ‹å˜å¾—æ›´åŠ è‡ªåŠ¨åŒ–å’Œæ™ºèƒ½åŒ–ã€‚

## ç»“è¯­

ç¼–ç¨‹è¯­è¨€çš„å†…å­˜æ¨¡å‹ä¸å¹¶å‘æ§åˆ¶æœºåˆ¶æ˜¯æ„å»ºå¯é å¹¶å‘ç¨‹åºçš„åŸºç¡€ã€‚ç†è§£ä¸åŒè¯­è¨€çš„å†…å­˜æ¨¡å‹å’Œå¹¶å‘æ§åˆ¶æœºåˆ¶ï¼Œé€‰æ‹©åˆé€‚çš„åŒæ­¥åŸè¯­ï¼Œéµå¾ªæœ€ä½³å®è·µï¼Œæ‰èƒ½ç¼–å†™å‡ºæ—¢æ­£ç¡®åˆé«˜æ•ˆçš„å¹¶å‘ç¨‹åºã€‚

::: theorem
è®°ä½ï¼šå¹¶å‘ç¼–ç¨‹ä¸æ˜¯å…³äºä»£ç å¦‚ä½•è¿è¡Œï¼Œè€Œæ˜¯å…³äºä»£ç å¦‚ä½•ä¸è¿è¡Œã€‚æ­£ç¡®çš„å¹¶å‘ç¨‹åºåº”è¯¥èƒ½å¤Ÿæ­£ç¡®å¤„ç†æ‰€æœ‰å¯èƒ½çš„æ‰§è¡Œé¡ºåºã€‚
::>

> "å¹¶å‘ç¼–ç¨‹æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€å›°éš¾çš„é—®é¢˜ä¹‹ä¸€ã€‚å¦‚æœä½ å‘ç°å¹¶å‘ç¼–ç¨‹å¾ˆå®¹æ˜“ï¼Œé‚£ä¹ˆä½ å¯èƒ½è¿˜ä¸ç†è§£å®ƒã€‚" â€” Rob Pike

å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½å¸®åŠ©ä½ æ›´å¥½åœ°ç†è§£ç¼–ç¨‹è¯­è¨€çš„å†…å­˜æ¨¡å‹ä¸å¹¶å‘æ§åˆ¶æœºåˆ¶ã€‚åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨å‡½æ•°å¼ç¼–ç¨‹ä¸å¹¶å‘çš„ç»“åˆï¼Œçœ‹çœ‹å‡½æ•°å¼èŒƒå¼å¦‚ä½•ç®€åŒ–å¹¶å‘ç¼–ç¨‹çš„å¤æ‚æ€§ã€‚ğŸš€