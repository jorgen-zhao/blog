---
title: Rust：这只螃蟹凭什么让 Linux 内核都为之折腰？
date: 2026-01-24 14:30:00
permalink: /pages/r8492z/
categories:
  - 编程语言
tags:
  - Rust
  - 系统编程
  - 技术杂谈
author:
  name: Jorgen
  link: https://github.com/jorgen-zhao
---

## 前言

俗话说得好："人生苦短，我用 Python"，但在某些高性能场景下，人生不仅苦短，还得还要跟内存泄漏斗智斗勇。于是乎，我开启了"每天学一门新语言"的（打脸）计划。今天的主角，是一只自带防暴盾牌的螃蟹——`Rust`。

为什么是 Rust？因为这玩意儿现在火得一塌糊涂，甚至连 Linux 内核这种顽固的"C 语言堡垒"都向它敞开了大门。今天这篇文章，我们要来一次深度的"扒皮"行动，聊聊这只螃蟹的前世今生，以及为什么它的学习曲线像过山车一样刺激。🎢

::: tip 核心观点
Rust 不仅仅是一门编程语言，它是一场关于"如何在不使用垃圾回收（GC）的情况下保证内存安全"的社会学实验。
:::

<!-- more -->

## 简史：一只名为 Rust 的螃蟹 🦀

Rust 的故事始于 2006 年，由 Mozilla 员工 Graydon Hoare 作为个人项目开发。据说起因是他家电梯的软件崩溃了（这听起来像个段子，但却是真的），于是他愤而决定写一个更安全的系统语言。

到了 2010 年，Mozilla 正式赞助该项目。Rust 的设计初衷很明确：**既要 C++ 的性能，又要 Java/Python 的内存安全**。

2015 年，Rust 1.0 正式发布。从此，这只螃蟹开始了它的征服之旅：
*   **Servo 浏览器引擎**：Rust 的第一个"练兵场"。
*   **WebAssembly**：Rust 成了编写 WASM 的首选语言之一。
*   **Linux 内核**：2022 年，Rust 成功进入 Linux 内核，成为继 C 语言之后的第二大官方语言。

## 为什么学习曲线陡峭得像座山？ ⛰️

说实话，学 Rust 的过程就像是跟一个极其严格、甚至有点强迫症的导师下棋。

如果你习惯了 Python 或 JavaScript 的随性，刚开始写 Rust 时你会感觉手脚被捆住了一样。主要原因有三点：

1.  **所有权机制**：这是 Rust 的灵魂。内存归谁管？什么时候借出去？什么时候还回来？编译器比你的前女友还记得清楚。
2.  **借用检查器**：这是 Rust 编译器里的"黑脸包公"。你写完代码，编译器会告诉你："嘿，你这里悬空指针了，我不给你过！" ~~刚开始我甚至想把电脑砸了，但后来发现，它拦住的都是 Bug。~~
3.  **生命周期**：这简直是劝退神器。 `'a`, `'static` 这些符号看着就像天书，但在理解之后，你会惊叹于它对内存管理的精确描述。

::: theorem 定理
在 Rust 中，只要你的代码能编译通过，它大概率就是安全的。这也就是所谓的 "If it compiles, it works"。
:::

## LLM 时代的"降维打击"学习法 🤖

以前学 Rust，我们要啃厚厚的《The Rust Programming Language》（简称 The Book）。但在 LLM 时代，学习路径已经发生了质变。

对于普通人，如何快速上手？我的建议是：

1.  **把 LLM 当作全天候导师**：不要只问它"怎么写代码"，要问"为什么"。比如，把报错信息直接扔给 ChatGPT/Claude，让它解释**借用检查器**为什么生气。
2.  **生成测试用例**：Rust 的测试体系很棒。让 LLM 帮你生成 Edge Cases 的测试代码，帮你覆盖那些你没考虑到的情况。
3.  **概念转译**：如果你懂 C++ 或 Java，让 LLM 用对比的方式教你。"用 Rust 的 `Match` 表达式实现 Java 的 `Switch-Case`，并解释区别"。

::: right
—— Jorgen 的学习心得：不要死记硬背语法，要让 AI 帮你建立思维模型。
:::

## 基础语法速览 ⚡

这里不搞那种教科书式的罗列，我们来点干货，感受一下 Rust 的"风味"。

**1. 变量与不可变性**
Rust 默认变量是不可变的，这很"函数式"。

```rust
let x = 5; // 默认不可变
// x = 6; // 报错！
let mut y = 5; // 加上 mut 就可以变
y = 6;
```

**2. 结构体与枚举**
Rust 的 `enum` 强大得离谱，不仅仅是状态列表，还可以带数据。

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
```

**3. 错误处理**
没有 `try-catch`，只有 `Result<T, E>` 和 `Option`。这强迫你处理每一个可能发生的错误。

```rust
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        return Err(String::from("Cannot divide by zero!"));
    }
    Ok(a / b)
}
```

## 最佳实践：写出"地道"的 Rust 🏆

不要写"像 C 语言的 Rust"，要写"Rust 语言的 Rust"。

*   **不要用 `.unwrap()`**：除非你在写测试代码，否则在生产环境用 `unwrap()` 就像在车里埋了一颗地雷。使用 `?` 运算符优雅地传递错误。
*   **拥抱迭代器**：Rust 的迭代器由于零成本抽象，非常高效。多用 `.map()`, `.filter()`, `.collect()`，少写手动的 `for` 循环。
*   **利用 Cargo**：包管理工具 Cargo 真的太好用了。善用 `cargo clippy`（更严格的 linter）和 `cargo fmt`。

## 这只螃蟹到底能干什么？🛠

Rust 的应用场景比你想象的要广：

1.  **系统编程**：操作系统内核、驱动程序。比如 Linux 内核现在就在用。
2.  **Web 后端**：通过 `Actix-web` 或 `Axum`，Rust 可以写出性能吊打 Node.js 和 Go 的后端服务（虽然开发效率可能稍低）。
3.  **CLI 工具**：`ripgrep` (grep 的替代品), `fd` (find 的替代品)。这些工具快得飞起，很多都开始用 Rust 重写。
4.  **嵌入式开发**：由于没有运行时开销，非常适合资源受限的设备。
5.  **WebAssembly**：把 Rust 编译成 WASM 在浏览器里跑，性能几乎接近原生。

## Linux 内核的"二当家"：凭什么？🐧

Linux 之父 Linus Torvalds 曾对 C++ 颇有微词，但却公开支持 Rust 进入内核。为什么？

因为 **安全**。

Linux 内核 60% 以上的严重安全漏洞源于内存安全问题（如缓冲区溢出、释放后使用）。C 语言给了程序员极大的自由，但也允许程序员把脚射断。Rust 通过编译期检查，在**不牺牲性能**的前提下，从根源上杜绝了这些错误。

::: tip 简单来说
C 语言像是一把没有保险的枪，威力大但容易走火；Rust 则是一把带有生物指纹锁的智能枪，只有确认安全才能击发。
:::

## Rust vs Go：宿命对决 ⚔️

这大概是当今技术圈最火的话题之一。我们来个客观的对比。

| 特性 | Rust | Go |
| :--- | :--- | :--- |
| **哲学** | 安全、性能、控制 | 简单、开发效率、并发 |
| **内存管理** | 所有权机制（无 GC） | 垃圾回收（GC） |
| **学习曲线** | 📈 极难 | 📉 平缓 |
| **性能** | 🏎️ 极高（接近 C++） | 🚗 快（优于 Java，但略逊于 Rust） |
| **并发** | `Send` 和 `Sync` Trait 保证 | Goroutines 和 Channels |
| **适用场景** | 系统底层、高频交易、嵌入 | 微服务、云原生基础设施 |

**结论**：
*   如果你追求**极致的性能**和**内存安全**，或者在做底层系统，选 **Rust**。
*   如果你追求**快速开发**、**团队协作**以及处理微服务逻辑，选 **Go**。

## 未来展望：Rust 会死吗？🔮

我的回答是：**短期内不会，而且活得会很好。**

编程语言的发展历史上，很多"更好"的语言死于生态不好（比如 Delphi）。但 Rust 目前已经跨过了"生态生死线"。
*   **WebAssembly** 的兴起为 Rust 提供了浏览器端的广阔天地。
*   **AI 基础设施**：很多 AI 推理框架（如 `candle`, `burn`）开始用 Rust 重写，因为 Python 在推理性能上确实有点力不从心。

至于未来编程语言的发展，有了 **LLM (大语言模型)** 的加持，语法复杂的劣势正在被抹平。
*   以前：语法难 -> 学习成本高 -> 劝退 -> 语言消亡。
*   现在：语法难 -> LLM 帮你写 -> 只有编译器拦你（但这正是安全保障） -> 语言生存。

Rust 的严格性，反而让它更容易被 AI 理解和生成（因为逻辑明确，不像动态语言那样玄学）。

## 总结

Rust 是一门让你**痛苦并快乐着**的语言。它强迫你直面内存管理的每一个细节，不允许你偷懒。

但正如一位大佬所说："Rust 的痛苦是编译时的痛苦，而 C++ 的痛苦是运行时（凌晨三点接到报警电话）的痛苦。" 🤷‍♂️

在 AI 辅助编程的今天，Rust 的学习门槛已经被大大降低了。如果你是一个追求技术深度、想搞清楚程序底层运行的开发者，那只螃蟹绝对值得你养一只。

> **最后的建议**：别害怕编译器报错，它是你的朋友。虽然它有时候说话很难听，但它真的在救你的命。