---
title: OTA
date: 2022-07-24 22:03:21
permalink: /pages/1a405f/
categories:
  - 开发日志
  - LiteIoT
  - 功能实现
tags:
  - 
author: 
  name: Jorgen
  link: https://gitee.com/jorgenme
---
# OTA
1. **软件版本管理**

   * 字段设计：升级包文件名称 =**发布日期（yyyy-MM-dd）_ 软件版本 _硬件版本_产品型号.bin（上传升级包时，命名完成给到服务器解析）**、版本说明、选择类型（非必选）：没选择—通用版；选择：专属版、服务器存放地址、备注、文件名、常用字段（新增、编辑\用户、时间）

   * 服务器端：先计算升级包的MD5校验码，然后提前将整个升级包划分成大小1024字节的子包，最后一个子包可以不满1024字节，再计算每个子包的BCC校验码，使用这些参数生成的OTA更新命令。

   * 设备请求升级包时，怎么区分版本：

     * ~~发布日期（yy-MM-dd）_ 软件版本 _硬件版本__产品型号_通用/专属~~
     * Redis设置：imei -- URL：通过URL去服务器匹配，不再通过查库的方式

     

2. **选择设备，软件包进行升级**

   * 字段设计：设备（组织、批次、设备名、号、当前软件版本、电量、设备状态、服务器最新版本）设备上报最新报文 + 设备信息 + 软件版本管理中 最新版本

   * **升级包优先**：选择完成升级包后，查询通过选择的升级包进行过滤设备（过滤设备版本低于当前选择升级包版本）

     * 设备上报最新版本（视图）inner join device where （添加检索条件）
     * 接口设计：
       * 升级包查询设计：获取全部升级包（权限）
       * 查询可升级设备设计：过滤正在进行升级的设备（获取设备升级的最新状态），根据选定的upgraderId（硬件版本一致，软件版本小于），再添加检索条件
       * 创建升级状态（任务）：传递设备升级的实体集合，软件版本Id

   * **设备优先**：服务器最新版本（同硬件版本下软件版本最高）

     * 设备上报最新版本（视图）inner join device （分页中取出响应的数据，获取单个设备的硬件版本，通过硬件版本匹配，查询软件版本最高的升级包。）
     * 视图：硬件版本中软件版本最高的升级包
     * 接口设计：
       * 查询设计：
       * 1. 组织过滤，查询服务器设备的当前版本，根据查询到的设备硬件版本分类；
         2. 根据组织（权限过滤），硬件版本版本去 【统一硬件版本下软件版本最高的视图】匹配硬件版本；
         3. 遍历1中设备，匹配硬件版本，将软件版本设置回去。
       * 创建升级状态（任务）：传递版本检查的实体集合，软件版本Id，升级类型（升级包优先、设备优先）参数

   * **注意**：

     * 目前OTA仅对研发人员开发，遵守谁升级谁上传升级包。版本检查中的组织过滤与系统保持一致。即可操作当前登录用户所在组织管辖下的设备或升级包。
     * 升级包为什么这样设计：
       1. 组织架构的设计是：从上可以往下，即上层管控下层，不能逆向。
       2. 每个组织下都可以有自己的版本约定，当出现重复时，无法区分。
       3. 通用包是根组织上传，其下所有的组织都可以使用。延伸开，最底层设备就会存在无法区分的情况。
       4. 所以：需要给那个（批）设备升级，就将升级包上传到对应的组织下，再进行升级。从下往上方便管理，从上往下会导致混乱。
       5. 限制：只能是管理员才可以操作，管理员所属一级组织，升级包存在其所在层级一级组织及其下，管理员有权限操作升级包
     * 所有已经在升级中的设备不出现

   * ~~**思考：**区分通用包与专属包？？？~~

     

3. **升级任务**

   * 字段设计：upgrader_id（版本名称、版本号）、imeis(设备号列表)，升级类型（设备优先，升级包优先）、升级时间、~~待升级、升级中、下载完成、升级成功、未知、升级失败、~~ 总升级数量

   * 创建：imeis(设备列表、逗号隔开)，软件版本Id，升级类型（升级包优先、设备优先）

   * ~~升级任务创建成功之后，获取到taskId，创建当个设备的升级记录。单个设备的升级记录状态变更时，反向通过taskId，更改升级任务中的状态数量统计（涉及到两个状态的数量增减）。~~

   * 查询升级记录，通过group by 状态（待升级、升级中、下载完成、升级成功、未知、升级失败）进行count各种状态的数量。

   * 点击详情：通过任务Id 与状态进行过滤查询

     

4. **升级记录**

   * 字段设计：taskId、设备（设备名、设备号、所属组织）、升级前版本、升级后版本、升级状态（）
   * ~~单个设备升级时，升级状态改变时，通过taskId改变升级任务中的状态统计~~
   * 后台：
     * 组装下发指令报文，设备上报时下发，触发补偿机制。
   * 设备获取升级包时查询该设备的升级记录最新一条获取recordId，创建升级过程记录。
   * 状态变更：
     * 根据上报的报文，变更升级记录中的升级状态（升级中【+ReqCOTAP】、下载完成【+COTAPOVER】、升级失败【+COTAPERR】-【OTACMDERR】）
     * 下发升级指令: 30s 待升级 --> 升级失败
     * 超时变更状态：升级中 --> 升级失败（超时时间：size * 30s）
     * 设备收到完成 --> 未知 （超时时间：10m）

   * 补偿机制：

     - [x] server下发升级指令，设备无响应？超时时间10s 失败
     - [x] 设备升级包获取，相邻包与包之间的超时时间：3min
     - [x] 设备收包到一半，设备无响应？超时时间：size * 30s 失败
     - [x] 设备收包完成，上报报文：10m 状态未知。若是中间出现了未知的版本，也可创建新的升级任务，下次设备上报，更改掉未知版本为确认版本（成功则不升级，失败则继续添加到升级列表中）


   ![OTA状态流转图](https://github.com/jorgen-zhao/coder_blog/blob/main/images/LiteIoT/OTA_status_flow.jpg?raw=true)

5. **升级过程记录**

   * 字段设计：recordId、ctr_time、current_packet_no、remark
   * 设备每次向服务器请求报文时，解析请求报文，记录详细。

   

6. **联调测试**

   前置准备：

   * 设备管理需要添加批次号 -- 选择批次号管理下的记录
   * 升级包管理，升级包名称里硬件版本按照新定义的方式进行命名 与 解析
   * 版本监测下，默认的硬件版本修改（现在是默认的硬件版本）

7. **特殊情况考虑**

   * 升级失败 -- 升级超时：异常情况考虑
   * 异常情况下，查询的操作（添加过滤）