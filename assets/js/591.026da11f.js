(window.webpackJsonp=window.webpackJsonp||[]).push([[591],{946:function(_,v,t){"use strict";t.r(v);var a=t(15),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[_._v("#")]),_._v(" 前言")]),_._v(" "),v("p",[_._v("在操作系统的世界里，资源是有限的，而进程对资源的需求却是无限的。当多个进程因争夺系统资源而造成一种互相等待的僵局，导致所有相关进程都无法继续执行时，我们就遇到了操作系统中最令人头疼的问题之一——"),v("strong",[_._v("死锁")]),_._v("。")]),_._v(" "),v("p",[_._v('想象一下这样的场景：两个人在狭窄的走廊相遇，互相礼让对方先过，结果谁也过不去。这就是生活中的"死锁"现象。在计算机系统中，死锁可能导致系统性能下降甚至完全瘫痪，因此理解死锁的原理、预防策略和解决方法对操作系统设计者和开发者至关重要。')]),_._v(" "),v("p",[_._v("本文将深入探讨死锁的四个必要条件、预防策略、避免算法以及检测与恢复方法，帮助读者全面理解这一操作系统经典问题。")]),_._v(" "),v("h2",{attrs:{id:"死锁的四个必要条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁的四个必要条件"}},[_._v("#")]),_._v(" 死锁的四个必要条件")]),_._v(" "),v("p",[_._v("根据Coffman等人于1971年提出的理论，死锁的发生必须同时满足以下四个条件：")]),_._v(" "),v("h3",{attrs:{id:"_1-互斥条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-互斥条件"}},[_._v("#")]),_._v(" 1. 互斥条件")]),_._v(" "),v("p",[_._v("一个资源在任意时刻只能被一个进程使用。如果另一个进程请求该资源，请求者必须等待，直到资源被释放。例如，打印机一次只能被一个进程使用。")]),_._v(" "),v("h3",{attrs:{id:"_2-占有并等待条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-占有并等待条件"}},[_._v("#")]),_._v(" 2. 占有并等待条件")]),_._v(" "),v("p",[_._v("一个进程因请求资源而阻塞时，对已获得的资源保持不放。例如，一个进程已经获得了打印机资源，同时又在等待扫描仪资源，即使扫描仪可能被其他进程使用。")]),_._v(" "),v("h3",{attrs:{id:"_3-不可剥夺条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-不可剥夺条件"}},[_._v("#")]),_._v(" 3. 不可剥夺条件")]),_._v(" "),v("p",[_._v("进程已获得的资源，在使用完之前不能被剥夺，只能在使用完时由自己释放。例如，进程正在使用打印机，系统不能强制收回打印机给其他进程使用。")]),_._v(" "),v("h3",{attrs:{id:"_4-循环等待条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-循环等待条件"}},[_._v("#")]),_._v(" 4. 循环等待条件")]),_._v(" "),v("p",[_._v("存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被下一个进程所请求。例如，进程P1等待进程P2的资源，进程P2等待进程P3的资源，而进程P3又等待进程P1的资源。")]),_._v(" "),v("div",{staticClass:"custom-block theorem"},[v("p",{staticClass:"title"},[_._v("THEOREM")]),v("p",[_._v("只有当以上四个条件同时满足时，才会发生死锁。因此，预防死锁的关键在于破坏这四个条件中的一个或多个。")])]),v("h2",{attrs:{id:"死锁的预防策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁的预防策略"}},[_._v("#")]),_._v(" 死锁的预防策略")]),_._v(" "),v("p",[_._v("预防死锁是通过破坏死锁的四个必要条件来实现的，主要有以下几种策略：")]),_._v(" "),v("h3",{attrs:{id:"_1-破坏互斥条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-破坏互斥条件"}},[_._v("#")]),_._v(" 1. 破坏互斥条件")]),_._v(" "),v("p",[v("strong",[_._v("思路")]),_._v("：允许资源同时被多个进程访问，即采用资源共享的方式。")]),_._v(" "),v("p",[v("strong",[_._v("实现方式")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("将某些资源改为可共享资源，如只读文件")]),_._v(" "),v("li",[_._v('使用"假脱机"技术，如假脱机打印，允许多个进程同时使用打印机')])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("并非所有资源都可以共享，如打印机、写文件等")]),_._v(" "),v("li",[_._v("可能导致系统性能下降和资源浪费")])]),_._v(" "),v("h3",{attrs:{id:"_2-破坏占有并等待条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-破坏占有并等待条件"}},[_._v("#")]),_._v(" 2. 破坏占有并等待条件")]),_._v(" "),v("p",[v("strong",[_._v("思路")]),_._v("：进程在请求资源前必须一次性申请所有需要的资源。")]),_._v(" "),v("p",[v("strong",[_._v("实现方式")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("资源一次性分配")]),_._v("：进程运行前，一次性申请所有需要的资源")]),_._v(" "),v("li",[v("strong",[_._v("资源预分配")]),_._v("：进程开始运行前，系统为其分配所需全部资源")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("资源利用率低，许多资源可能长时间闲置")]),_._v(" "),v("li",[_._v("可能导致进程饥饿，某些进程因无法获得全部资源而永远无法运行")])]),_._v(" "),v("h3",{attrs:{id:"_3-破坏不可剥夺条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-破坏不可剥夺条件"}},[_._v("#")]),_._v(" 3. 破坏不可剥夺条件")]),_._v(" "),v("p",[v("strong",[_._v("思路")]),_._v("：当进程因请求资源而阻塞时，必须释放已获得的资源。")]),_._v(" "),v("p",[v("strong",[_._v("实现方式")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("如果进程请求的资源不能立即分配，则释放所有已获得的资源")]),_._v(" "),v("li",[_._v("当进程再次运行时，重新申请所有资源")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("实现复杂，需要回滚进程状态")]),_._v(" "),v("li",[_._v("可能导致进程前功尽弃，增加系统开销")])]),_._v(" "),v("h3",{attrs:{id:"_4-破坏循环等待条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-破坏循环等待条件"}},[_._v("#")]),_._v(" 4. 破坏循环等待条件")]),_._v(" "),v("p",[v("strong",[_._v("思路")]),_._v("：对所有资源进行编号，进程必须按编号顺序请求资源。")]),_._v(" "),v("p",[v("strong",[_._v("实现方式")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("为每种资源类型赋予一个唯一编号")]),_._v(" "),v("li",[_._v("规定进程必须按编号递增的顺序请求资源")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("限制了资源的灵活使用")]),_._v(" "),v("li",[_._v("可能导致某些进程无法获得资源，即使资源处于空闲状态")])]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("提示")]),_._v(" "),v("p",[_._v("在实际系统中，通常采用破坏循环等待条件的方法预防死锁，因为它对系统性能影响较小且实现相对简单。")])]),_._v(" "),v("h2",{attrs:{id:"死锁的避免算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁的避免算法"}},[_._v("#")]),_._v(" 死锁的避免算法")]),_._v(" "),v("p",[_._v("死锁预防策略可能会限制系统的并发性和资源利用率，而死锁避免则是在资源分配过程中进行判断，确保系统不会进入不安全状态。")]),_._v(" "),v("h3",{attrs:{id:"_1-安全状态与不安全状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-安全状态与不安全状态"}},[_._v("#")]),_._v(" 1. 安全状态与不安全状态")]),_._v(" "),v("p",[v("strong",[_._v("安全状态")]),_._v("：如果系统能够按某种顺序为每个进程分配其所需资源，直至满足最大需求，则称系统处于安全状态。")]),_._v(" "),v("p",[v("strong",[_._v("不安全状态")]),_._v("：如果不存在这样的分配顺序，则系统处于不安全状态。不安全状态不一定会导致死锁，但如果进程继续申请资源，则可能进入死锁。")]),_._v(" "),v("h3",{attrs:{id:"_2-银行家算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-银行家算法"}},[_._v("#")]),_._v(" 2. 银行家算法")]),_._v(" "),v("p",[_._v("银行家算法是最著名的死锁避免算法，由Dijkstra于1965年提出。该算法模拟银行家如何安全地分配资金给客户。")]),_._v(" "),v("p",[v("strong",[_._v("算法核心")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("当进程请求资源时，系统先假定分配该资源")]),_._v(" "),v("li",[_._v("然后检查系统是否仍处于安全状态")]),_._v(" "),v("li",[_._v("如果安全，则分配资源；否则，拒绝请求")])]),_._v(" "),v("p",[v("strong",[_._v("数据结构")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("Available")]),_._v("：可用资源向量")]),_._v(" "),v("li",[v("code",[_._v("Max")]),_._v("：最大需求矩阵")]),_._v(" "),v("li",[v("code",[_._v("Allocation")]),_._v("：已分配矩阵")]),_._v(" "),v("li",[v("code",[_._v("Need")]),_._v("：需求矩阵（Need = Max - Allocation）")])]),_._v(" "),v("p",[v("strong",[_._v("算法步骤")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("初始化：检查进程请求是否小于其需求")]),_._v(" "),v("li",[_._v("假定分配：更新Available和Allocation")]),_._v(" "),v("li",[_._v("安全性检查：\n"),v("ul",[v("li",[_._v("初始化Work = Available，Finish = [false, false, ..., false]")]),_._v(" "),v("li",[_._v("寻找满足Need[i] ≤ Work的进程i")]),_._v(" "),v("li",[_._v("如果找到，设置Work = Work + Allocation[i]，Finish[i] = true，重复步骤")]),_._v(" "),v("li",[_._v("如果所有进程Finish[i] = true，系统安全；否则不安全")])])])]),_._v(" "),v("p",[v("strong",[_._v("优缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("优点")]),_._v("：允许进程动态申请资源，提高了资源利用率")]),_._v(" "),v("li",[v("strong",[_._v("缺点")]),_._v("：需要提前知道进程的最大资源需求，实现复杂，系统开销大")])]),_._v(" "),v("h3",{attrs:{id:"_3-资源排序算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-资源排序算法"}},[_._v("#")]),_._v(" 3. 资源排序算法")]),_._v(" "),v("p",[_._v("另一种死锁避免方法是资源排序算法，通过为资源类型赋予唯一优先级，并规定进程必须按优先级顺序请求资源。")]),_._v(" "),v("p",[v("strong",[_._v("算法特点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("每种资源类型有一个唯一优先级")]),_._v(" "),v("li",[_._v("进程必须按优先级递增的顺序请求资源")]),_._v(" "),v("li",[_._v("可以避免循环等待条件")])]),_._v(" "),v("p",[v("strong",[_._v("适用场景")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("适用于资源类型较少且优先级明确的系统")]),_._v(" "),v("li",[_._v("实现简单，但灵活性较差")])]),_._v(" "),v("h2",{attrs:{id:"死锁的检测与恢复"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁的检测与恢复"}},[_._v("#")]),_._v(" 死锁的检测与恢复")]),_._v(" "),v("p",[_._v("在某些系统中，死锁预防或避免的成本过高，此时可以采用死锁检测与恢复策略。")]),_._v(" "),v("h3",{attrs:{id:"_1-死锁检测算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-死锁检测算法"}},[_._v("#")]),_._v(" 1. 死锁检测算法")]),_._v(" "),v("p",[_._v("死锁检测算法定期检查系统是否处于死锁状态。常用的算法包括：")]),_._v(" "),v("h4",{attrs:{id:"资源分配图算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#资源分配图算法"}},[_._v("#")]),_._v(" 资源分配图算法")]),_._v(" "),v("p",[v("strong",[_._v("基本概念")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("资源分配图是一个有向图，包括进程节点和资源节点")]),_._v(" "),v("li",[_._v("从进程指向资源的边表示请求边")]),_._v(" "),v("li",[_._v("从资源指向进程的边表示分配边")])]),_._v(" "),v("p",[v("strong",[_._v("检测步骤")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("构建资源分配图")]),_._v(" "),v("li",[_._v("寻找环路：\n"),v("ul",[v("li",[_._v("移除所有分配边")]),_._v(" "),v("li",[_._v("如果存在进程节点没有入边，则移除该节点及其所有出边")]),_._v(" "),v("li",[_._v("重复上述过程，直到无法移除节点")])])]),_._v(" "),v("li",[_._v("如果图中仍有节点，则存在死锁")])]),_._v(" "),v("h4",{attrs:{id:"死锁检测矩阵算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁检测矩阵算法"}},[_._v("#")]),_._v(" 死锁检测矩阵算法")]),_._v(" "),v("p",[_._v("该算法使用矩阵运算来检测死锁，类似于银行家算法的安全性检查。")]),_._v(" "),v("h3",{attrs:{id:"_2-死锁恢复策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-死锁恢复策略"}},[_._v("#")]),_._v(" 2. 死锁恢复策略")]),_._v(" "),v("p",[_._v("当检测到系统处于死锁状态时，可以采用以下恢复策略：")]),_._v(" "),v("h4",{attrs:{id:"_1-进程终止"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程终止"}},[_._v("#")]),_._v(" 1. 进程终止")]),_._v(" "),v("p",[v("strong",[_._v("选择终止进程的策略")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("终止所有死锁进程")]),_._v("：简单粗暴但可能导致大量工作丢失")]),_._v(" "),v("li",[v("strong",[_._v("逐个终止进程")]),_._v("：每次终止一个死锁进程，直到死锁解除")]),_._v(" "),v("li",[v("strong",[_._v("基于优先级终止")]),_._v("：优先终止低优先级或代价小的进程")])]),_._v(" "),v("p",[v("strong",[_._v("考虑因素")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("进程的运行时间和已用CPU时间")]),_._v(" "),v("li",[_._v("进程完成所需的时间")]),_._v(" "),v("li",[_._v("进程已使用的资源数量")]),_._v(" "),v("li",[_._v("进程的类型（交互式或批处理）")])]),_._v(" "),v("h4",{attrs:{id:"_2-资源抢占"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-资源抢占"}},[_._v("#")]),_._v(" 2. 资源抢占")]),_._v(" "),v("p",[v("strong",[_._v("思路")]),_._v("：从一个或多个进程中抢占资源，分配给死锁进程。")]),_._v(" "),v("p",[v("strong",[_._v("实现方式")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("回滚：将被抢占进程的状态回滚到某个安全状态")]),_._v(" "),v("li",[_._v("事务：使用事务来确保资源抢占可以原子性地执行")])]),_._v(" "),v("p",[v("strong",[_._v("挑战")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("可能导致大量计算工作丢失")]),_._v(" "),v("li",[_._v("实现复杂，需要保存和恢复进程状态")])]),_._v(" "),v("div",{staticClass:"custom-block right"},[v("p",[_._v('"预防胜于治疗"——这句话同样适用于操作系统中的死锁问题。')])]),_._v(" "),v("h2",{attrs:{id:"结语"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[_._v("#")]),_._v(" 结语")]),_._v(" "),v("p",[_._v("死锁是操作系统设计中不可避免的问题，理解死锁的原理和解决方案对构建健壮的系统至关重要。本文详细探讨了死锁的四个必要条件、预防策略、避免算法以及检测与恢复方法。")]),_._v(" "),v("p",[_._v("在实际系统中，选择哪种死锁处理策略取决于具体的应用场景和系统需求。对于关键系统，如银行交易系统，通常采用保守的死锁预防策略；而对于一般用途的操作系统，则可能采用死锁检测与恢复策略，以平衡系统性能和可靠性。")]),_._v(" "),v("p",[_._v("随着云计算和分布式系统的发展，死锁问题也呈现出新的挑战和解决方案。未来的操作系统设计需要更加智能和自适应的 deadlock 处理机制，以应对日益复杂的系统环境和资源竞争。")]),_._v(" "),v("p",[_._v("作为开发者，我们应该深入理解死锁的本质，在系统设计和编码实践中避免死锁的发生，构建更加稳定可靠的软件系统。")]),_._v(" "),v("blockquote",[v("p",[_._v('"在计算机科学中，我们解决了所有问题，只是通过创造新问题的方式。" —— 操作系统设计中的死锁问题正是这句话的生动体现。')])])])}),[],!1,null,null,null);v.default=s.exports}}]);