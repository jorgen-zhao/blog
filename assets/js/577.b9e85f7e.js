(window.webpackJsonp=window.webpackJsonp||[]).push([[577],{930:function(t,s,a){"use strict";a.r(s);var r=a(15),v=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),s("p",[t._v("嗨，大家好！在前面的文章中，我们已经一起漫游了计算机系统的奇妙世界，也深入探讨了操作系统的核心调度单元——进程与线程。但是，"),s("s",[t._v("有没有想过，当我们的程序在CPU上欢快地运行时，它们的数据都待在哪里呢？")]),t._v(" 没错，就是内存！今天，我们就来聊聊操作系统如何像一位精明的资源分配大师，高效地管理着计算机中最珍贵的资源之一——内存。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("内存管理是操作系统的核心功能之一，它负责跟踪每个内存单元的状态，决定哪些进程可以使用哪些内存单元，以及何时分配和回收内存。")])]),t._v(" "),s("h2",{attrs:{id:"内存的基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存的基本概念"}},[t._v("#")]),t._v(" 内存的基本概念")]),t._v(" "),s("h3",{attrs:{id:"什么是内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是内存"}},[t._v("#")]),t._v(" 什么是内存？")]),t._v(" "),s("p",[t._v("内存（Memory）是计算机中用于临时存储数据和指令的硬件组件。与硬盘不同，内存的读写速度非常快，但断电后数据会丢失。我们可以把内存想象成一张办公桌，而硬盘则是文件柜：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("办公桌（内存）")]),t._v("：空间有限，但取放东西非常快，适合当前正在处理的工作")]),t._v(" "),s("li",[s("strong",[t._v("文件柜（硬盘）")]),t._v("：空间大，但取放东西慢，适合长期存储")])]),t._v(" "),s("h3",{attrs:{id:"地址空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#地址空间"}},[t._v("#")]),t._v(" 地址空间")]),t._v(" "),s("p",[t._v("每个进程都有自己的"),s("strong",[t._v("地址空间")]),t._v("（Address Space），这是进程可以使用的内存地址范围。地址空间分为几个部分：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("代码段")]),t._v("：存储程序的机器指令")]),t._v(" "),s("li",[s("strong",[t._v("数据段")]),t._v("：存储全局变量和静态变量")]),t._v(" "),s("li",[s("strong",[t._v("堆")]),t._v("：用于动态内存分配")]),t._v(" "),s("li",[s("strong",[t._v("栈")]),t._v("：存储局部变量和函数调用信息")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/memory-layout.png",alt:"内存布局示意图"}})]),t._v(" "),s("div",{staticClass:"custom-block theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("p",[t._v("地址空间隔离是操作系统的基本要求之一，确保一个进程不能随意访问另一个进程的内存空间，从而保证系统的安全性。")])]),s("h2",{attrs:{id:"虚拟内存-内存管理的革命"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存-内存管理的革命"}},[t._v("#")]),t._v(" 虚拟内存：内存管理的革命")]),t._v(" "),s("h3",{attrs:{id:"为什么需要虚拟内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要虚拟内存"}},[t._v("#")]),t._v(" 为什么需要虚拟内存？")]),t._v(" "),s("p",[t._v("没有虚拟内存的早期计算机系统中，程序必须完全加载到物理内存中才能运行。这带来了几个问题：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("内存碎片")]),t._v("：随着程序的加载和卸载，内存中会产生许多无法利用的小块空间")]),t._v(" "),s("li",[s("strong",[t._v("内存容量限制")]),t._v("：程序大小不能超过物理内存大小")]),t._v(" "),s("li",[s("strong",[t._v("内存利用率低")]),t._v("：同时运行的程序总大小可能远小于物理内存，但无法有效利用空闲内存")])]),t._v(" "),s("h3",{attrs:{id:"虚拟内存的工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存的工作原理"}},[t._v("#")]),t._v(" 虚拟内存的工作原理")]),t._v(" "),s("p",[t._v("虚拟内存技术通过以下方式解决了这些问题：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("地址转换")]),t._v("：将程序的虚拟地址转换为物理地址")]),t._v(" "),s("li",[s("strong",[t._v("分页")]),t._v("：将内存和进程地址空间划分为固定大小的块（页）")]),t._v(" "),s("li",[s("strong",[t._v("按需加载")]),t._v("：只将程序实际需要的部分加载到内存中")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/virtual-memory.png",alt:"虚拟内存工作原理"}})]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("虚拟内存让每个进程都认为自己拥有独立的、连续的地址空间，而实际上这些地址可能分散在物理内存的不同位置。")])]),t._v(" "),s("h2",{attrs:{id:"页面置换算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面置换算法"}},[t._v("#")]),t._v(" 页面置换算法")]),t._v(" "),s("h3",{attrs:{id:"页面错误"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面错误"}},[t._v("#")]),t._v(" 页面错误")]),t._v(" "),s("p",[t._v("当进程访问的页面不在内存中时，就会发生"),s("strong",[t._v("页面错误")]),t._v("（Page Fault）。此时，操作系统必须从磁盘加载所需的页面到内存中，如果内存已满，还需要先选择一个页面换出到磁盘。")]),t._v(" "),s("h3",{attrs:{id:"常见的页面置换算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的页面置换算法"}},[t._v("#")]),t._v(" 常见的页面置换算法")]),t._v(" "),s("p",[t._v("下面是一些经典的页面置换算法及其特点：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("算法名称")]),t._v(" "),s("th",[t._v("描述")]),t._v(" "),s("th",[t._v("优点")]),t._v(" "),s("th",[t._v("缺点")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("strong",[t._v("FIFO")])]),t._v(" "),s("td",[t._v("先进入内存的页面先被换出")]),t._v(" "),s("td",[t._v("实现简单")]),t._v(" "),s("td",[t._v("可能会出现Belady异常")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("LRU")])]),t._v(" "),s("td",[t._v("最近最少使用的页面被换出")]),t._v(" "),s("td",[t._v("性能较好")]),t._v(" "),s("td",[t._v("实现成本高")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("LFU")])]),t._v(" "),s("td",[t._v("访问频率最低的页面被换出")]),t._v(" "),s("td",[t._v("适合访问模式稳定")]),t._v(" "),s("td",[t._v("可能换出短期频繁使用的页面")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("OPT")])]),t._v(" "),s("td",[t._v("换出最长时间不会被使用的页面")]),t._v(" "),s("td",[t._v("理论最优")]),t._v(" "),s("td",[t._v("无法实现，仅用于比较")])])])]),t._v(" "),s("h3",{attrs:{id:"lru算法的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lru算法的实现"}},[t._v("#")]),t._v(" LRU算法的实现")]),t._v(" "),s("p",[t._v("LRU（Least Recently Used）算法是一种性能较好的页面置换策略，但实现起来有一定挑战：")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用哈希表+双向链表实现LRU缓存")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" prev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LRUCache")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" capacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashTable")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" hash_table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("div",{staticClass:"custom-block right"},[s("p",[t._v('"程序员的三大美德：懒惰、急躁和傲慢。" —— Larry Wall，Perl语言创造者')])]),t._v(" "),s("h2",{attrs:{id:"内存分配策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存分配策略"}},[t._v("#")]),t._v(" 内存分配策略")]),t._v(" "),s("h3",{attrs:{id:"固定分区-vs-动态分区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#固定分区-vs-动态分区"}},[t._v("#")]),t._v(" 固定分区 vs 动态分区")]),t._v(" "),s("p",[t._v("内存分配主要有两种策略：")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("固定分区")]),t._v("：将内存划分为固定大小的分区，每个分区可以容纳一个进程")]),t._v(" "),s("ul",[s("li",[t._v("优点：实现简单，分配速度快")]),t._v(" "),s("li",[t._v("缺点：分区大小固定，难以适应不同大小的进程需求")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("动态分区")]),t._v("：根据进程的实际需求分配内存")]),t._v(" "),s("ul",[s("li",[t._v("优点：内存利用率高")]),t._v(" "),s("li",[t._v("缺点：容易产生外部碎片")])])])]),t._v(" "),s("h3",{attrs:{id:"动态分区分配算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态分区分配算法"}},[t._v("#")]),t._v(" 动态分区分配算法")]),t._v(" "),s("p",[t._v("常见的动态分区分配算法包括：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("首次适应（First Fit）")]),t._v("：选择第一个足够大的空闲分区")]),t._v(" "),s("li",[s("strong",[t._v("最佳适应（Best Fit）")]),t._v("：选择足够大的最小空闲分区")]),t._v(" "),s("li",[s("strong",[t._v("最坏适应（Worst Fit）")]),t._v("：选择足够大的最大空闲分区")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/dynamic-partitioning.png",alt:"动态分区分配"}})]),t._v(" "),s("h2",{attrs:{id:"内存映射文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存映射文件"}},[t._v("#")]),t._v(" 内存映射文件")]),t._v(" "),s("h3",{attrs:{id:"什么是内存映射文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是内存映射文件"}},[t._v("#")]),t._v(" 什么是内存映射文件？")]),t._v(" "),s("p",[s("strong",[t._v("内存映射文件")]),t._v("（Memory-mapped File）是一种将文件或文件部分直接映射到进程地址空间的技术。这使得文件访问就像访问内存一样简单高效。")]),t._v(" "),s("h3",{attrs:{id:"内存映射的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存映射的优势"}},[t._v("#")]),t._v(" 内存映射的优势")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("简化文件I/O")]),t._v("：无需显式的read/write系统调用")]),t._v(" "),s("li",[s("strong",[t._v("提高性能")]),t._v("：利用操作系统的页面缓存和预读机制")]),t._v(" "),s("li",[s("strong",[t._v("进程间通信")]),t._v("：多个进程可以映射同一文件，实现高效的数据共享")])]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用mmap映射文件的示例")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mmap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" addr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" prot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" fd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("off_t")]),t._v(" offset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("h2",{attrs:{id:"结语"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[t._v("#")]),t._v(" 结语")]),t._v(" "),s("p",[t._v("今天，我们一起探索了操作系统内存管理的精彩世界。从基本的内存概念到革命性的虚拟内存技术，从页面置换算法到内存分配策略，我们看到了操作系统如何巧妙地管理这一宝贵资源。")]),t._v(" "),s("p",[t._v("内存管理是操作系统中最复杂也最有趣的部分之一，它直接影响着应用程序的性能和系统的稳定性。理解内存管理不仅有助于我们写出更高效的程序，也能让我们对计算机系统有更深的认识。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("作为开发者，了解内存管理原理可以帮助我们写出更高效的代码，避免常见的内存问题，如内存泄漏、缓冲区溢出等。\n::>")]),t._v(" "),s("p",[t._v("未来，随着计算机体系结构的不断演进，内存管理技术也将继续发展。从NUMA架构到持久性内存，从非易失性内存到新型存储级内存，这些新技术都将为操作系统带来新的挑战和机遇。")]),t._v(" "),s("p",[t._v("希望这篇文章能帮助你更好地理解操作系统的内存管理机制。如果你有任何问题或想法，欢迎在评论区留言交流！让我们一起在计算机科学的奇妙旅程中继续前行！🚀")])])])}),[],!1,null,null,null);s.default=v.exports}}]);