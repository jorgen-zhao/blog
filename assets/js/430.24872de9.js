(window.webpackJsonp=window.webpackJsonp||[]).push([[430],{782:function(a,t,_){"use strict";_.r(t);var v=_(15),e=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),t("p",[a._v("在分布式系统中，保证节点间的一致性是一个核心问题。CAP理论告诉我们，在分布式系统中，一致性(Consistency)、可用性(Availability)和分区容忍性(Partition tolerance)三者不可兼得。而BASE理论则为我们提供了一种在保证最终一致性的前提下，实现高可用性的方法。")]),a._v(" "),t("p",[a._v("然而，这些理论只是为我们提供了方向，如何在实际系统中实现一致性呢？这就需要依赖各种一致性协议。其中，Paxos算法是最早提出的一致性算法，但由于其复杂性和难以理解，在实际应用中并不广泛。为了解决这个问题，Diego Ongaro和John Ousterhout提出了Raft算法。")]),a._v(" "),t("p",[a._v("本文将详细介绍Raft算法的原理、实现和应用，帮助读者理解这一重要的分布式共识算法。")]),a._v(" "),t("h2",{attrs:{id:"raft算法概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raft算法概述"}},[a._v("#")]),a._v(" Raft算法概述")]),a._v(" "),t("p",[a._v("Raft是一种为可理解性而设计的分布式共识算法。它通过将一致性问题分解为 leader 选举、日志复制和安全性的几个部分，使得算法更加直观和易于实现。")]),a._v(" "),t("p",[a._v("Raft的核心思想是：在任何时候，一个集群中只有一个leader，所有客户端的请求都由leader处理，leader将操作以日志的形式复制到其他follower节点，当大多数节点都成功复制后，leader才将该日志应用到状态机中。")]),a._v(" "),t("div",{staticClass:"custom-block theorem"},[t("p",{staticClass:"title"},[a._v("THEOREM")]),t("p",[a._v("Raft算法保证在满足以下条件的情况下，系统可以保持一致性：")]),a._v(" "),t("ol",[t("li",[a._v("任何两个时间点，最多只有一个leader")]),a._v(" "),t("li",[a._v("leader必须包含所有已提交的日志条目")]),a._v(" "),t("li",[a._v("如果一个日志条目在某个服务器上提交，那么它最终也会在所有服务器上提交")])])]),t("h2",{attrs:{id:"raft的核心组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raft的核心组件"}},[a._v("#")]),a._v(" Raft的核心组件")]),a._v(" "),t("p",[a._v("Raft算法主要由以下几个核心组件构成：")]),a._v(" "),t("h3",{attrs:{id:"_1-节点状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-节点状态"}},[a._v("#")]),a._v(" 1. 节点状态")]),a._v(" "),t("p",[a._v("在Raft中，每个节点有三种可能的状态：")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("Leader")]),a._v("：处理所有客户端请求，并将日志复制到其他节点")]),a._v(" "),t("li",[t("strong",[a._v("Follower")]),a._v("：被动响应来自leader和其他candidate的请求")]),a._v(" "),t("li",[t("strong",[a._v("Candidate")]),a._v("：用于选举新的leader")])]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),t("p",[a._v("节点状态转换：")]),a._v(" "),t("ul",[t("li",[a._v("Follower：在收到leader的心跳消息后保持状态")]),a._v(" "),t("li",[a._v("如果Follower在选举超时时间内没有收到leader的消息，它会转换为Candidate状态")]),a._v(" "),t("li",[a._v("Candidate如果在选举中获得大多数选票，它会转换为Leader状态")]),a._v(" "),t("li",[a._v("如果Candidate发现已经有其他leader存在，它会转换回Follower状态")])])]),a._v(" "),t("h3",{attrs:{id:"_2-任期-term"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-任期-term"}},[a._v("#")]),a._v(" 2. 任期(Term)")]),a._v(" "),t("p",[a._v("Raft将时间划分为一个个的任期，每个任期用一个递增的数字表示。每个任期从一次选举开始，如果选举成功，则leader在该任期内负责；如果选举失败，则会开始一个新的任期。")]),a._v(" "),t("p",[a._v("任期的概念帮助Raft处理各种边界情况，如leader崩溃、网络分区等。")]),a._v(" "),t("h3",{attrs:{id:"_3-日志-log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-日志-log"}},[a._v("#")]),a._v(" 3. 日志(Log)")]),a._v(" "),t("p",[a._v("Raft中的日志是一系列有序的日志条目，每个日志条目包含：")]),a._v(" "),t("ul",[t("li",[a._v("命令内容：客户端请求的具体操作")]),a._v(" "),t("li",[a._v("任期号：创建该日志条目的leader的任期号")])]),a._v(" "),t("p",[a._v("日志是Raft实现一致性的关键，leader将客户端的请求以日志条目的形式复制到所有follower节点。")]),a._v(" "),t("h3",{attrs:{id:"_4-状态机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-状态机"}},[a._v("#")]),a._v(" 4. 状态机")]),a._v(" "),t("p",[a._v("状态机是每个节点上实际执行命令的组件。Raft保证如果所有状态机以相同的顺序执行相同的命令集，那么它们将处于相同的状态。")]),a._v(" "),t("h2",{attrs:{id:"raft的核心机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raft的核心机制"}},[a._v("#")]),a._v(" Raft的核心机制")]),a._v(" "),t("h3",{attrs:{id:"_1-leader选举"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-leader选举"}},[a._v("#")]),a._v(" 1. Leader选举")]),a._v(" "),t("p",[a._v("当系统启动或者现有leader崩溃时，需要选举新的leader。选举过程如下：")]),a._v(" "),t("ol",[t("li",[a._v("Follower如果在选举超时时间内没有收到leader的心跳消息，它会增加当前任期号，转换为Candidate状态，并为自己投票")]),a._v(" "),t("li",[a._v("Candidate向其他节点发送RequestVote RPC请求，请求其他节点为自己投票")]),a._v(" "),t("li",[a._v("其他节点会根据以下条件决定是否投票给该Candidate：\n"),t("ul",[t("li",[a._v("该节点的任期号不小于自己的任期号")]),a._v(" "),t("li",[a._v("该节点自己还没有投票给其他Candidate")]),a._v(" "),t("li",[a._v("该节点的日志至少和自己一样新（即该节点的日志包含所有已提交的日志，并且最后一条日志的任期号不小于自己的最后一条日志的任期号）")])])]),a._v(" "),t("li",[a._v("如果Candidate获得大多数节点的投票，它就转换为Leader")]),a._v(" "),t("li",[a._v("Leader开始向所有Follower发送心跳消息，以维护自己的leader地位")])]),a._v(" "),t("div",{staticClass:"custom-block right"},[t("p",[t("em",[a._v("选举过程确保了只有拥有最新日志的节点才能成为leader，从而保证了日志的一致性")])])]),a._v(" "),t("h3",{attrs:{id:"_2-日志复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-日志复制"}},[a._v("#")]),a._v(" 2. 日志复制")]),a._v(" "),t("p",[a._v("当leader收到客户端的请求后，它会执行以下步骤：")]),a._v(" "),t("ol",[t("li",[a._v("将命令追加到自己的日志中")]),a._v(" "),t("li",[a._v("通过AppendEntries RPC将该日志条目复制到所有Follower节点")]),a._v(" "),t("li",[a._v("当leader收到大多数Follower对该日志条目的成功响应后，将该日志标记为已提交")]),a._v(" "),t("li",[a._v("leader通知所有Follower将该日志应用到状态机中")])]),a._v(" "),t("p",[a._v("日志复制过程保证了所有节点的日志最终会保持一致。")]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),t("p",[a._v("Raft通过以下机制保证日志的一致性：")]),a._v(" "),t("ol",[t("li",[a._v("leader为每个Follower维护一个nextIndex，表示下一次要发送的日志条目的索引")]),a._v(" "),t("li",[a._v("如果Follower的日志与leader不一致，leader会递减nextIndex，直到找到一致的位置")]),a._v(" "),t("li",[a._v("Follower只会接受leader的日志，并且只会按照leader的顺序应用日志")])])]),a._v(" "),t("h3",{attrs:{id:"_3-安全性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-安全性"}},[a._v("#")]),a._v(" 3. 安全性")]),a._v(" "),t("p",[a._v("Raft通过以下机制保证系统的安全性：")]),a._v(" "),t("ol",[t("li",[a._v("选举限制：只有拥有最新日志的节点才能成为leader")]),a._v(" "),t("li",[a._v("提交限制：leader只有在大多数节点都复制了某个日志条目后，才能提交该日志条目")]),a._v(" "),t("li",[a._v("提交之前任期的日志：leader不会直接提交之前任期的日志，而是通过提交当前任期的日志来间接提交之前任期的日志")])]),a._v(" "),t("h2",{attrs:{id:"raft算法的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raft算法的应用"}},[a._v("#")]),a._v(" Raft算法的应用")]),a._v(" "),t("p",[a._v("Raft算法由于其易于理解和实现的特点，被广泛应用于各种分布式系统中：")]),a._v(" "),t("ol",[t("li",[t("strong",[a._v("etcd")]),a._v("：CoreOS开发的分布式键值存储系统，使用Raft算法保证一致性")]),a._v(" "),t("li",[t("strong",[a._v("Consul")]),a._v("：HashiCorp开发的分布式服务发现和配置工具，使用Raft算法实现一致性")]),a._v(" "),t("li",[t("strong",[a._v("CockroachDB")]),a._v("：NewSQL数据库，使用Raft算法实现分布式事务")]),a._v(" "),t("li",[t("strong",[a._v("TiDB")]),a._v("：分布式SQL数据库，使用Raft算法实现分布式事务")])]),a._v(" "),t("h2",{attrs:{id:"raft算法的优势与局限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raft算法的优势与局限"}},[a._v("#")]),a._v(" Raft算法的优势与局限")]),a._v(" "),t("h3",{attrs:{id:"优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[a._v("#")]),a._v(" 优势")]),a._v(" "),t("ol",[t("li",[t("strong",[a._v("可理解性")]),a._v("：Raft通过将问题分解为几个部分，使得算法更加直观和易于理解")]),a._v(" "),t("li",[t("strong",[a._v("可实现性")]),a._v("：Raft的论文中包含了完整的实现细节，使得开发者可以更容易地实现该算法")]),a._v(" "),t("li",[t("strong",[a._v("性能")]),a._v("：Raft的性能与Paxos相当，在某些场景下甚至优于Paxos")]),a._v(" "),t("li",[t("strong",[a._v("可用性")]),a._v("：Raft支持在大多数节点正常工作的情况下提供服务，具有高可用性")])]),a._v(" "),t("h3",{attrs:{id:"局限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#局限"}},[a._v("#")]),a._v(" 局限")]),a._v(" "),t("ol",[t("li",[t("strong",[a._v("写性能受限")]),a._v("：由于所有写操作都需要通过leader，写性能可能成为瓶颈")]),a._v(" "),t("li",[t("strong",[a._v("leader选举开销")]),a._v("：频繁的leader选举可能会影响系统的性能")]),a._v(" "),t("li",[t("strong",[a._v("日志复制延迟")]),a._v("：由于需要大多数节点确认，日志复制可能存在一定的延迟")])]),a._v(" "),t("h2",{attrs:{id:"结语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[a._v("#")]),a._v(" 结语")]),a._v(" "),t("p",[a._v("Raft算法通过将分布式一致性问题分解为几个易于理解的部分，为我们提供了一种简单而有效的解决方案。它不仅保证了系统的一致性和可用性，还通过易于理解的设计降低了实现的复杂度。")]),a._v(" "),t("p",[a._v("在实际应用中，我们可以基于Raft算法构建各种分布式系统，如分布式存储、分布式数据库、分布式消息队列等。同时，我们也应该认识到Raft算法的局限性，根据实际场景进行优化和改进。")]),a._v(" "),t("p",[a._v("随着分布式系统的广泛应用，理解并掌握Raft这样的共识算法变得越来越重要。希望本文能够帮助读者更好地理解Raft算法，并在实际工作中加以应用。")]),a._v(" "),t("blockquote",[t("p",[a._v('"简单是复杂的终极形式。" — 达芬奇')])])])}),[],!1,null,null,null);t.default=e.exports}}]);