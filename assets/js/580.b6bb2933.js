(window.webpackJsonp=window.webpackJsonp||[]).push([[580],{932:function(_,v,t){"use strict";t.r(v);var a=t(15),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[_._v("#")]),_._v(" 前言")]),_._v(" "),v("p",[_._v("在之前的文章中，我们已经了解了计算机系统的基本构成和操作系统的核心调度单元——进程与线程。然而，"),v("s",[_._v("没有内存管理的操作系统就像没有仓库的工厂")]),_._v("，即使有再好的调度策略，也无法高效地运行程序。")]),_._v(" "),v("p",[_._v("内存管理是操作系统的核心功能之一，它负责跟踪内存的使用情况，分配和回收内存空间，以及保护内存不被未授权访问。今天，我们就来深入探讨这个看似平凡却至关重要的主题。")]),_._v(" "),v("h2",{attrs:{id:"内存管理的基本功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存管理的基本功能"}},[_._v("#")]),_._v(" 内存管理的基本功能")]),_._v(" "),v("p",[_._v("内存管理主要完成以下几项任务：")]),_._v(" "),v("h3",{attrs:{id:"_1-内存分配与回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存分配与回收"}},[_._v("#")]),_._v(" 1. 内存分配与回收")]),_._v(" "),v("p",[_._v("操作系统需要为进程分配内存空间，并在进程结束时回收这些空间。这就像是一个图书馆管理员，负责借书和还书。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("静态分配")]),_._v("：在程序运行前分配全部所需内存")]),_._v(" "),v("li",[v("strong",[_._v("动态分配")]),_._v("：在程序运行过程中按需分配")])]),_._v(" "),v("h3",{attrs:{id:"_2-地址转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-地址转换"}},[_._v("#")]),_._v(" 2. 地址转换")]),_._v(" "),v("p",[_._v("物理地址和逻辑地址之间的转换是内存管理的关键环节。当程序访问内存时，需要将逻辑地址转换为物理地址。")]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("提示")]),_._v(" "),v("p",[_._v('逻辑地址是程序自己使用的地址空间，而物理地址是实际内存中的地址。操作系统就像是一个翻译官，帮助程序理解内存的"真实地址"。')])]),_._v(" "),v("h3",{attrs:{id:"_3-内存保护"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存保护"}},[_._v("#")]),_._v(" 3. 内存保护")]),_._v(" "),v("p",[_._v("确保每个进程只能访问自己的内存空间，防止恶意程序破坏其他进程或操作系统本身。")]),_._v(" "),v("h2",{attrs:{id:"虚拟内存-内存管理的革命"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存-内存管理的革命"}},[_._v("#")]),_._v(" 虚拟内存：内存管理的革命")]),_._v(" "),v("p",[_._v("虚拟内存是现代操作系统中最具革命性的内存管理技术之一。它允许每个进程拥有独立的地址空间，即使物理内存不足也能运行大型程序。")]),_._v(" "),v("h3",{attrs:{id:"为什么需要虚拟内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要虚拟内存"}},[_._v("#")]),_._v(" 为什么需要虚拟内存？")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("地址空间隔离")]),_._v("：每个进程都认为自己拥有完整的内存空间")]),_._v(" "),v("li",[v("strong",[_._v("内存利用率提高")]),_._v("：只有实际使用的部分才会加载到物理内存")]),_._v(" "),v("li",[v("strong",[_._v("程序大小不受物理内存限制")]),_._v("：可以运行比物理内存更大的程序")])]),_._v(" "),v("h3",{attrs:{id:"虚拟内存的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存的实现"}},[_._v("#")]),_._v(" 虚拟内存的实现")]),_._v(" "),v("p",[_._v("虚拟内存通常通过"),v("strong",[_._v("分页")]),_._v("技术实现。将物理内存划分为固定大小的块（页框），将虚拟内存也划分为同样大小的块（页）。")]),_._v(" "),v("p",[v("img",{attrs:{src:"/images/virtual_memory.png",alt:"虚拟内存示意图"}})]),_._v(" "),v("div",{staticClass:"custom-block theorem"},[v("p",{staticClass:"title"},[_._v("THEOREM")]),v("p",[_._v("当进程访问一个不在物理内存中的页时，会触发"),v("strong",[_._v("缺页中断")]),_._v("，操作系统需要从磁盘加载该页到内存中。")])]),v("h2",{attrs:{id:"页面置换算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#页面置换算法"}},[_._v("#")]),_._v(" 页面置换算法")]),_._v(" "),v("p",[_._v("当物理内存已满，又需要加载新页面时，操作系统必须决定替换哪个现有页面。这就是页面置换算法要解决的问题。")]),_._v(" "),v("h3",{attrs:{id:"常见的页面置换算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的页面置换算法"}},[_._v("#")]),_._v(" 常见的页面置换算法")]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("FIFO（先进先出）")])]),_._v(" "),v("ul",[v("li",[_._v("最简单的算法，替换最早进入内存的页面")]),_._v(" "),v("li",[_._v("可能出现"),v("strong",[_._v("Belady异常")]),_._v("：分配更多页框反而导致缺页率增加")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("LRU（最近最少使用）")])]),_._v(" "),v("ul",[v("li",[_._v("替换最近最久未使用的页面")]),_._v(" "),v("li",[_._v("性能较好，但实现开销大")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("OPT（最优置换）")])]),_._v(" "),v("ul",[v("li",[_._v("理想算法，替换未来最长时间内不会被访问的页面")]),_._v(" "),v("li",[_._v("无法实际实现，但可作为其他算法的比较基准")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("Clock（时钟）算法")])]),_._v(" "),v("ul",[v("li",[_._v("LRU的近似实现，开销较小")])])])]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("提示")]),_._v(" "),v("p",[_._v("在实际系统中，通常会使用多级页面置换算法，结合多种策略以获得最佳性能。")])]),_._v(" "),v("h2",{attrs:{id:"内存分段与分页"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存分段与分页"}},[_._v("#")]),_._v(" 内存分段与分页")]),_._v(" "),v("p",[_._v("内存管理主要有两种方式：分段和分页。")]),_._v(" "),v("h3",{attrs:{id:"分段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分段"}},[_._v("#")]),_._v(" 分段")]),_._v(" "),v("ul",[v("li",[_._v("根据程序的逻辑结构划分内存")]),_._v(" "),v("li",[_._v("每个段有不同的长度")]),_._v(" "),v("li",[_._v("支持共享和保护")])]),_._v(" "),v("h3",{attrs:{id:"分页"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分页"}},[_._v("#")]),_._v(" 分页")]),_._v(" "),v("ul",[v("li",[_._v("将内存划分为固定大小的页")]),_._v(" "),v("li",[_._v("管理简单，碎片少")]),_._v(" "),v("li",[_._v("但可能将逻辑相关的页面分散在不同位置")])]),_._v(" "),v("p",[_._v("现代操作系统通常采用"),v("strong",[_._v("段页式管理")]),_._v("，先分段再分页，结合两者的优点。")]),_._v(" "),v("h2",{attrs:{id:"现代操作系统中的内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#现代操作系统中的内存管理"}},[_._v("#")]),_._v(" 现代操作系统中的内存管理")]),_._v(" "),v("h3",{attrs:{id:"linux内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#linux内存管理"}},[_._v("#")]),_._v(" Linux内存管理")]),_._v(" "),v("p",[_._v("Linux采用分页式内存管理，具有以下特点：")]),_._v(" "),v("ul",[v("li",[_._v("三级页表结构")]),_._v(" "),v("li",[_._v("支持大页（Huge Pages）提高性能")]),_._v(" "),v("li",[_._v("内存压缩（KSM）技术合并相同页面")])]),_._v(" "),v("h3",{attrs:{id:"windows内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#windows内存管理"}},[_._v("#")]),_._v(" Windows内存管理")]),_._v(" "),v("p",[_._v("Windows的内存管理更加复杂，包括：")]),_._v(" "),v("ul",[v("li",[_._v("32位和64位不同的地址空间布局")]),_._v(" "),v("li",[_._v("工作集（Working Set）概念")]),_._v(" "),v("li",[_._v("内存管理器（Memory Manager）组件")])]),_._v(" "),v("h2",{attrs:{id:"结语"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[_._v("#")]),_._v(" 结语")]),_._v(" "),v("p",[_._v("内存管理看似是一个底层的技术细节，但它直接影响着应用程序的性能和系统的稳定性。从简单的固定分区到复杂的虚拟内存技术，内存管理的发展历程也反映了计算机技术的进步。")]),_._v(" "),v("p",[_._v("随着云计算和大数据时代的到来，对高效内存管理的需求越来越迫切。未来的内存管理技术可能会更加智能化，能够根据应用程序的特点自动调整内存分配策略，进一步提高系统性能。")]),_._v(" "),v("blockquote",[v("p",[_._v('正如一位计算机科学家所说："在计算机科学中，我们几乎所有的难题都可以通过增加一个间接层来解决。"而虚拟内存，正是这个理念的最佳体现。')])]),_._v(" "),v("p",[_._v("希望这篇文章能帮助你更好地理解操作系统的内存管理机制。如果你有任何问题或想法，欢迎在评论区交流！")])])}),[],!1,null,null,null);v.default=s.exports}}]);