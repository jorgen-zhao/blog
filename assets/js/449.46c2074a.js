(window.webpackJsonp=window.webpackJsonp||[]).push([[449],{799:function(_,v,t){"use strict";t.r(v);var a=t(15),r=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[_._v("#")]),_._v(" 前言")]),_._v(" "),v("p",[_._v("在分布式系统的世界里，我们常常面临各种挑战。节点可能会崩溃，网络可能会延迟，消息可能会丢失。这些问题在CAP理论、Paxos和Raft等算法中得到了广泛的研究和解决。然而，还有一种更复杂、更棘手的问题："),v("strong",[_._v("拜占庭将军问题")]),_._v("。")]),_._v(" "),v("p",[_._v("拜占庭将军问题是分布式系统中的一个经典难题，它描述了在存在恶意节点（可能发送错误信息或故意破坏系统）的情况下，如何达成共识。这个问题由Leslie Lamport等人在1982年首次提出，名字来源于拜占庭帝国的将军们需要通过信使传递信息，决定是进攻还是撤退的故事。")]),_._v(" "),v("p",[_._v("在本文中，我们将深入探讨拜占庭将军问题，并介绍一种实用的拜占庭容错算法——PBFT（Practical Byzantine Fault Tolerance）。理解这些内容对于构建安全可靠的分布式系统，特别是在需要高安全性的领域（如金融系统、区块链等）至关重要。")]),_._v(" "),v("h2",{attrs:{id:"拜占庭将军问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#拜占庭将军问题"}},[_._v("#")]),_._v(" 拜占庭将军问题")]),_._v(" "),v("h3",{attrs:{id:"问题背景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题背景"}},[_._v("#")]),_._v(" 问题背景")]),_._v(" "),v("p",[_._v("想象一下，拜占庭帝国有多位将军，他们分别驻扎在不同的城市，需要共同决定是进攻还是撤退。将军们只能通过信使传递信息，而信使可能会延迟、丢失消息，甚至被敌人截获并伪造消息。")]),_._v(" "),v("p",[_._v("更糟糕的是，其中一些将军可能是"),v("strong",[_._v("叛徒")]),_._v("，他们会故意发送错误的信息，试图破坏将军们达成一致的决定。")]),_._v(" "),v("p",[_._v("问题在于：如何在存在叛徒的情况下，让忠诚的将军们达成一致的决定（进攻或撤退）？")]),_._v(" "),v("h3",{attrs:{id:"问题形式化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题形式化"}},[_._v("#")]),_._v(" 问题形式化")]),_._v(" "),v("p",[_._v("拜占庭将军问题可以形式化为：")]),_._v(" "),v("ul",[v("li",[_._v("有N个将军，其中最多有f个是叛徒（恶意节点）。")]),_._v(" "),v("li",[_._v("所有忠诚的将军必须做出相同的决定（进攻或撤退）。")]),_._v(" "),v("li",[_._v("如果所有忠诚的将军都提议进攻，那么最终的决定必须是进攻；如果所有忠诚的将军都提议撤退，那么最终的决定必须是撤退。")])]),_._v(" "),v("p",[_._v("为了达成共识，需要满足以下条件：")]),_._v(" "),v("p",[_._v("N > 3f")]),_._v(" "),v("p",[_._v("也就是说，总节点数必须大于3倍的恶意节点数。这意味着系统必须拥有足够的冗余，才能容忍一定比例的恶意节点。")]),_._v(" "),v("h3",{attrs:{id:"为什么难以解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么难以解决"}},[_._v("#")]),_._v(" 为什么难以解决")]),_._v(" "),v("p",[_._v("拜占庭将军问题之所以难以解决，主要有以下几个原因：")]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("恶意节点可以任意行为")]),_._v("：与简单的故障节点不同，恶意节点可以发送任意信息，甚至可以发送不同的信息给不同的节点。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("难以验证信息的真实性")]),_._v("：在分布式系统中，节点通常无法直接验证其他节点发送的信息是否真实。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("需要更高的冗余度")]),_._v("：相比故障停止模型，拜占庭容错需要更多的节点（N > 3f）才能达成共识。")])])]),_._v(" "),v("h2",{attrs:{id:"pbft算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pbft算法"}},[_._v("#")]),_._v(" PBFT算法")]),_._v(" "),v("p",[_._v("面对拜占庭将军问题的挑战，Miguel Castro和Barbara Liskov在1999年提出了"),v("strong",[_._v("PBFT（Practical Byzantine Fault Tolerance）算法")]),_._v("，一种实用的拜占庭容错算法。PBFT能够在N > 3f的条件下，处理f个恶意节点，保证系统的安全性和活性。")]),_._v(" "),v("h3",{attrs:{id:"pbft的基本原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pbft的基本原理"}},[_._v("#")]),_._v(" PBFT的基本原理")]),_._v(" "),v("p",[_._v("PBFT是一种基于状态机复制的算法，其核心思想是通过多轮消息交换，在所有节点之间达成共识。算法主要包括三个阶段：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("请求阶段（Request）")]),_._v("：客户端向主节点发送请求。")]),_._v(" "),v("li",[v("strong",[_._v("预准备阶段（Pre-prepare）")]),_._v("：主节点将请求广播给所有备份节点。")]),_._v(" "),v("li",[v("strong",[_._v("准备阶段（Prepare）")]),_._v("：备份节点验证请求后，向所有节点发送准备消息。")]),_._v(" "),v("li",[v("strong",[_._v("提交阶段（Commit）")]),_._v("：节点收到足够多的准备消息后，向所有节点发送提交消息。")]),_._v(" "),v("li",[v("strong",[_._v("回复阶段（Reply）")]),_._v("：节点收到足够多的提交消息后，执行请求并向客户端回复。")])]),_._v(" "),v("h3",{attrs:{id:"pbft的详细流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pbft的详细流程"}},[_._v("#")]),_._v(" PBFT的详细流程")]),_._v(" "),v("p",[_._v("让我们更详细地了解PBFT的工作流程：")]),_._v(" "),v("h4",{attrs:{id:"_1-系统配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-系统配置"}},[_._v("#")]),_._v(" 1. 系统配置")]),_._v(" "),v("p",[_._v("PBFT系统通常由一组节点组成，包括一个主节点（Primary）和多个备份节点（Backup）。节点之间通过完全连通的网络连接，消息传递是异步的。")]),_._v(" "),v("h4",{attrs:{id:"_2-视图变更"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-视图变更"}},[_._v("#")]),_._v(" 2. 视图变更")]),_._v(" "),v("p",[_._v('PBFT使用"视图"（View）的概念来管理节点。每个视图都有一个主节点，主节点负责处理客户端请求。当主节点可能存在拜占庭行为时，系统会触发视图变更，选举新的主节点。')]),_._v(" "),v("h4",{attrs:{id:"_3-三阶段提交"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-三阶段提交"}},[_._v("#")]),_._v(" 3. 三阶段提交")]),_._v(" "),v("p",[_._v("PBFT的核心是三阶段提交协议：")]),_._v(" "),v("p",[v("strong",[_._v("第一阶段：预准备（Pre-prepare）")])]),_._v(" "),v("ul",[v("li",[_._v("主节点接收到客户端的请求后，为请求分配一个序列号，并向所有备份节点发送预准备消息。")]),_._v(" "),v("li",[_._v("预准备消息包含：视图编号、序列号、请求摘要和主节点签名。")])]),_._v(" "),v("p",[v("strong",[_._v("第二阶段：准备（Prepare）")])]),_._v(" "),v("ul",[v("li",[_._v("备份节点验证预准备消息的有效性（如序列号是否连续、请求摘要是否匹配等）。")]),_._v(" "),v("li",[_._v("如果验证通过，备份节点向所有节点（包括主节点）发送准备消息。")]),_._v(" "),v("li",[_._v("准备消息包含：视图编号、序列号、节点签名。")])]),_._v(" "),v("p",[v("strong",[_._v("第三阶段：提交（Commit）")])]),_._v(" "),v("ul",[v("li",[_._v("当节点收到2f+1个有效的准备消息（包括来自主节点的预准备消息）后，向所有节点发送提交消息。")]),_._v(" "),v("li",[_._v("提交消息包含：视图编号、序列号、节点签名。")])]),_._v(" "),v("h4",{attrs:{id:"_4-请求执行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-请求执行"}},[_._v("#")]),_._v(" 4. 请求执行")]),_._v(" "),v("p",[_._v("当节点收到2f+1个有效的提交消息后，执行请求并向客户端发送回复。")]),_._v(" "),v("h3",{attrs:{id:"pbft的正确性证明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pbft的正确性证明"}},[_._v("#")]),_._v(" PBFT的正确性证明")]),_._v(" "),v("p",[_._v("PBFT算法的正确性基于以下两个性质：")]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("安全性（Safety）")]),_._v("：在存在f个恶意节点的情况下，系统仍然能保证所有非恶意节点执行相同的请求序列，且不会执行错误的请求。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("活性（Liveness）")]),_._v("：只要主节点是非恶意的，系统就能处理客户端的请求并给出回复。")])])]),_._v(" "),v("p",[_._v("这些性质通过以下机制保证：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("序列号分配")]),_._v("：主节点为每个请求分配唯一的序列号，确保请求的顺序性。")]),_._v(" "),v("li",[v("strong",[_._v("多数派确认")]),_._v("：每个阶段都需要2f+1个节点的确认，这保证了即使有f个恶意节点，仍然有f+1个非恶意节点能够达成一致。")]),_._v(" "),v("li",[v("strong",[_._v("视图变更")]),_._v("：当主节点可能存在拜占庭行为时，系统可以触发视图变更，选举新的主节点。")])]),_._v(" "),v("h2",{attrs:{id:"pbft的应用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pbft的应用场景"}},[_._v("#")]),_._v(" PBFT的应用场景")]),_._v(" "),v("p",[_._v("PBFT算法由于其高效性和实用性，在许多领域得到了广泛应用：")]),_._v(" "),v("h3",{attrs:{id:"_1-区块链系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-区块链系统"}},[_._v("#")]),_._v(" 1. 区块链系统")]),_._v(" "),v("p",[_._v("许多联盟链（如Hyperledger Fabric、Stellar等）使用PBFT或其变种作为共识机制。与工作量证明（PoW）和权益证明（PoS）不同，PBFT不需要复杂的计算，能够在几秒钟内完成共识，适合需要高吞吐量和低延迟的场景。")]),_._v(" "),v("h3",{attrs:{id:"_2-金融系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-金融系统"}},[_._v("#")]),_._v(" 2. 金融系统")]),_._v(" "),v("p",[_._v("在金融交易、支付清算等系统中，一致性和安全性至关重要。PBFT能够在保证安全性的同时提供高性能，适合这些场景。")]),_._v(" "),v("h3",{attrs:{id:"_3-分布式数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-分布式数据库"}},[_._v("#")]),_._v(" 3. 分布式数据库")]),_._v(" "),v("p",[_._v("一些分布式数据库（如TiDB、CockroachDB等）使用PBFT或其变种来实现分布式事务和共识。")]),_._v(" "),v("h3",{attrs:{id:"_4-云计算和微服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-云计算和微服务"}},[_._v("#")]),_._v(" 4. 云计算和微服务")]),_._v(" "),v("p",[_._v("在云计算和微服务架构中，PBFT可以用于服务发现、配置管理、分布式锁等场景，确保系统的一致性和可靠性。")]),_._v(" "),v("h2",{attrs:{id:"pbft的优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pbft的优缺点"}},[_._v("#")]),_._v(" PBFT的优缺点")]),_._v(" "),v("h3",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[_._v("#")]),_._v(" 优点")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("高性能")]),_._v("：PBFT的延迟是O(n)，其中n是节点数量，适合小规模、高要求的系统。")]),_._v(" "),v("li",[v("strong",[_._v("确定性")]),_._v("：与工作量证明等概率性算法不同，PBFT是确定性的，一旦达成共识就不会分叉。")]),_._v(" "),v("li",[v("strong",[_._v("能源效率")]),_._v("：不需要复杂的计算，能源消耗低。")]),_._v(" "),v("li",[v("strong",[_._v("实用性")]),_._v("：能够在实际系统中有效运行，并且有成熟的实现。")])]),_._v(" "),v("h3",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[_._v("#")]),_._v(" 缺点")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("可扩展性有限")]),_._v("：随着节点数量的增加，通信开销会线性增长，不适合大规模系统。")]),_._v(" "),v("li",[v("strong",[_._v("需要预先知道节点数量")]),_._v("：PBFT需要在系统启动时确定所有节点，难以支持动态加入和离开。")]),_._v(" "),v("li",[v("strong",[_._v("需要同步网络")]),_._v("：PBFT假设网络是同步的，在异步网络中可能无法保证安全性。")]),_._v(" "),v("li",[v("strong",[_._v("需要验证签名")]),_._v("：每个消息都需要签名和验证，增加了计算开销。")])]),_._v(" "),v("h2",{attrs:{id:"pbft的变种与优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pbft的变种与优化"}},[_._v("#")]),_._v(" PBFT的变种与优化")]),_._v(" "),v("p",[_._v("为了克服PBFT的局限性，研究者们提出了许多变种和优化方案：")]),_._v(" "),v("h3",{attrs:{id:"_1-hotstuff"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-hotstuff"}},[_._v("#")]),_._v(" 1. HotStuff")]),_._v(" "),v("p",[_._v("HotStuff是Facebook开发的共识算法，是PBFT的变种，具有更好的模块化和可扩展性。它被应用于Diem（原Libra）区块链项目。")]),_._v(" "),v("h3",{attrs:{id:"_2-tendermint"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-tendermint"}},[_._v("#")]),_._v(" 2. Tendermint")]),_._v(" "),v("p",[_._v("Tendermint是另一个PBFT的变种，具有更好的性能和可扩展性，被许多区块链项目采用。")]),_._v(" "),v("h3",{attrs:{id:"_3-sbft-scalable-byzantine-fault-tolerance"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-sbft-scalable-byzantine-fault-tolerance"}},[_._v("#")]),_._v(" 3. SBFT（Scalable Byzantine Fault Tolerance）")]),_._v(" "),v("p",[_._v("SBFT是一种可扩展的拜占庭容错算法，通过分层结构提高了系统的可扩展性。")]),_._v(" "),v("h3",{attrs:{id:"_4-rbft-redundant-byzantine-fault-tolerance"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-rbft-redundant-byzantine-fault-tolerance"}},[_._v("#")]),_._v(" 4. RBFT（Redundant Byzantine Fault Tolerance）")]),_._v(" "),v("p",[_._v("RBFT通过引入冗余节点，提高了系统的容错能力和性能。")]),_._v(" "),v("h2",{attrs:{id:"拜占庭容错与其他共识算法的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#拜占庭容错与其他共识算法的比较"}},[_._v("#")]),_._v(" 拜占庭容错与其他共识算法的比较")]),_._v(" "),v("h3",{attrs:{id:"与paxos和raft的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#与paxos和raft的比较"}},[_._v("#")]),_._v(" 与Paxos和Raft的比较")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("特性")]),_._v(" "),v("th",[_._v("Paxos/Raft")]),_._v(" "),v("th",[_._v("PBFT")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("容错模型")]),_._v(" "),v("td",[_._v("故障停止")]),_._v(" "),v("td",[_._v("拜占庭")])]),_._v(" "),v("tr",[v("td",[_._v("恶意节点容忍")]),_._v(" "),v("td",[_._v("0")]),_._v(" "),v("td",[_._v("f < N/3")])]),_._v(" "),v("tr",[v("td",[_._v("网络模型")]),_._v(" "),v("td",[_._v("部分同步")]),_._v(" "),v("td",[_._v("同步")])]),_._v(" "),v("tr",[v("td",[_._v("可扩展性")]),_._v(" "),v("td",[_._v("较好")]),_._v(" "),v("td",[_._v("较差")])]),_._v(" "),v("tr",[v("td",[_._v("应用场景")]),_._v(" "),v("td",[_._v("分布式系统、数据库")]),_._v(" "),v("td",[_._v("区块链、金融系统")])])])]),_._v(" "),v("h3",{attrs:{id:"与工作量证明-pow-的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#与工作量证明-pow-的比较"}},[_._v("#")]),_._v(" 与工作量证明（PoW）的比较")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("特性")]),_._v(" "),v("th",[_._v("PoW")]),_._v(" "),v("th",[_._v("PBFT")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("共识机制")]),_._v(" "),v("td",[_._v("概率性")]),_._v(" "),v("td",[_._v("确定性")])]),_._v(" "),v("tr",[v("td",[_._v("能源效率")]),_._v(" "),v("td",[_._v("低")]),_._v(" "),v("td",[_._v("高")])]),_._v(" "),v("tr",[v("td",[_._v("可扩展性")]),_._v(" "),v("td",[_._v("较好")]),_._v(" "),v("td",[_._v("较差")])]),_._v(" "),v("tr",[v("td",[_._v("去中心化程度")]),_._v(" "),v("td",[_._v("高")]),_._v(" "),v("td",[_._v("低")])]),_._v(" "),v("tr",[v("td",[_._v("交易确认时间")]),_._v(" "),v("td",[_._v("长")]),_._v(" "),v("td",[_._v("短")])])])]),_._v(" "),v("h2",{attrs:{id:"实现pbft的挑战与解决方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现pbft的挑战与解决方案"}},[_._v("#")]),_._v(" 实现PBFT的挑战与解决方案")]),_._v(" "),v("h3",{attrs:{id:"_1-签名验证的开销"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-签名验证的开销"}},[_._v("#")]),_._v(" 1. 签名验证的开销")]),_._v(" "),v("p",[_._v("PBFT依赖于数字签名来验证消息的真实性，但签名验证的计算开销较大。")]),_._v(" "),v("p",[v("strong",[_._v("解决方案")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("使用高效的签名算法（如ECDSA）。")]),_._v(" "),v("li",[_._v("使用批量验证技术，一次性验证多个签名。")]),_._v(" "),v("li",[_._v("使用硬件加速（如TPM、SGX等）。")])]),_._v(" "),v("h3",{attrs:{id:"_2-动态成员管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-动态成员管理"}},[_._v("#")]),_._v(" 2. 动态成员管理")]),_._v(" "),v("p",[_._v("PBFT需要在系统启动时确定所有节点，难以支持动态加入和离开。")]),_._v(" "),v("p",[v("strong",[_._v("解决方案")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("使用视图变更机制来动态调整节点集合。")]),_._v(" "),v("li",[_._v("引入注册表和认证机制，管理节点身份。")]),_._v(" "),v("li",[_._v("使用分片技术，将系统分成多个子集，每个子集独立运行PBFT。")])]),_._v(" "),v("h3",{attrs:{id:"_3-网络同步问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-网络同步问题"}},[_._v("#")]),_._v(" 3. 网络同步问题")]),_._v(" "),v("p",[_._v("PBFT假设网络是同步的，在异步网络中可能无法保证安全性。")]),_._v(" "),v("p",[v("strong",[_._v("解决方案")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("使用超时机制检测网络分区。")]),_._v(" "),v("li",[_._v("引入心跳检测，监控节点状态。")]),_._v(" "),v("li",[_._v("使用部分同步模型，放宽对网络同步的要求。")])]),_._v(" "),v("h3",{attrs:{id:"_4-性能优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-性能优化"}},[_._v("#")]),_._v(" 4. 性能优化")]),_._v(" "),v("p",[_._v("随着节点数量的增加，PBFT的性能会下降。")]),_._v(" "),v("p",[v("strong",[_._v("解决方案")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("使用批处理技术，将多个请求打包处理。")]),_._v(" "),v("li",[_._v("引入流水线技术，并行处理不同阶段的请求。")]),_._v(" "),v("li",[_._v("使用分片技术，将系统分成多个子集，并行运行PBFT。")])]),_._v(" "),v("h2",{attrs:{id:"结语"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[_._v("#")]),_._v(" 结语")]),_._v(" "),v("p",[_._v("拜占庭将军问题是分布式系统中的一个经典难题，它描述了在存在恶意节点的情况下如何达成共识。PBFT算法作为一种实用的拜占庭容错算法，通过三阶段提交协议，能够在N > 3f的条件下处理f个恶意节点，保证系统的安全性和活性。")]),_._v(" "),v("p",[_._v("PBFT算法在区块链、金融系统、分布式数据库等领域得到了广泛应用，特别是在需要高安全性和确定性的场景中。然而，PBFT也存在可扩展性有限、需要预先知道节点数量等缺点，研究者们提出了许多变种和优化方案来克服这些局限性。")]),_._v(" "),v("p",[_._v("理解拜占庭将军问题和PBFT算法对于构建安全可靠的分布式系统至关重要。在实际应用中，我们需要根据具体场景的需求，选择合适的共识算法，并进行适当的优化和改进。")]),_._v(" "),v("blockquote",[v("p",[_._v('"在分布式系统中，信任是最稀缺的资源。拜占庭容错算法教会我们如何在不可信的环境中建立信任。"')])]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("希望这篇文章能够帮助你理解拜占庭将军问题和PBFT算法。如果你有任何问题或建议，欢迎在评论区留言讨论！")])])}),[],!1,null,null,null);v.default=r.exports}}]);