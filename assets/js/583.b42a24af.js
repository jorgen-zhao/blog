(window.webpackJsonp=window.webpackJsonp||[]).push([[583],{935:function(t,a,v){"use strict";v.r(a);var s=v(15),_=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("在计算机科学的世界里，操作系统就像是一位大管家，负责管理计算机的各种资源，包括CPU、内存、I/O设备等。在之前的文章中，我们已经了解了计算机系统的基本组成和进程与线程这些核心调度单元。今天，我想和大家聊聊操作系统的另一位重要角色——内存管理器。")]),t._v(" "),a("p",[t._v("想象一下，如果没有内存管理，每个程序都需要直接访问物理内存，程序员需要手动管理内存的分配和释放，这将是多么恐怖的一件事！😱 幸运的是，操作系统为我们提供了强大的内存管理机制，让我们能够专注于程序逻辑，而不是内存管理的细节。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("内存管理是操作系统的核心功能之一，它负责跟踪内存的使用情况，满足进程的内存请求，并尽可能提高内存的利用率和系统性能。")])]),t._v(" "),a("h2",{attrs:{id:"内存管理的基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存管理的基本概念"}},[t._v("#")]),t._v(" 内存管理的基本概念")]),t._v(" "),a("h3",{attrs:{id:"什么是内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是内存"}},[t._v("#")]),t._v(" 什么是内存？")]),t._v(" "),a("p",[t._v("内存（Memory），也称为随机存取存储器（RAM），是计算机中用于临时存储数据和指令的硬件设备。与硬盘不同，内存的读写速度非常快，但断电后数据会丢失。")]),t._v(" "),a("p",[t._v("在操作系统中，内存被划分为多个固定大小的块，每个块都有一个唯一的地址。当程序运行时，它的指令和数据需要加载到内存中才能被CPU执行。")]),t._v(" "),a("h3",{attrs:{id:"内存管理的目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存管理的目标"}},[t._v("#")]),t._v(" 内存管理的目标")]),t._v(" "),a("p",[t._v("内存管理的主要目标包括：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("抽象")]),t._v("：为程序员提供一个简单、统一的内存模型，隐藏物理内存的复杂细节。")]),t._v(" "),a("li",[a("strong",[t._v("保护")]),t._v("：确保每个进程只能访问自己的内存空间，防止进程间的相互干扰。")]),t._v(" "),a("li",[a("strong",[t._v("共享")]),t._v("：允许多个进程访问相同的内存区域，提高内存利用率。")]),t._v(" "),a("li",[a("strong",[t._v("虚拟化")]),t._v("：为每个进程提供独立的地址空间，使它们感觉自己拥有整个内存。")]),t._v(" "),a("li",[a("strong",[t._v("效率")]),t._v("：尽可能提高内存的利用率，减少内存碎片，提高系统性能。")])]),t._v(" "),a("h2",{attrs:{id:"内存管理技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存管理技术"}},[t._v("#")]),t._v(" 内存管理技术")]),t._v(" "),a("h3",{attrs:{id:"连续内存分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连续内存分配"}},[t._v("#")]),t._v(" 连续内存分配")]),t._v(" "),a("p",[t._v("最简单的内存分配方式是连续内存分配，即为每个进程分配一块连续的物理内存空间。")]),t._v(" "),a("h4",{attrs:{id:"固定分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#固定分区"}},[t._v("#")]),t._v(" 固定分区")]),t._v(" "),a("p",[t._v("固定分区将内存划分为固定大小的分区，每个分区可以运行一个进程。这种方法的优点是实现简单，缺点是内存利用率低，容易产生内部碎片。")]),t._v(" "),a("h4",{attrs:{id:"动态分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态分区"}},[t._v("#")]),t._v(" 动态分区")]),t._v(" "),a("p",[t._v("动态分区根据进程的实际需求分配内存，分区的大小和位置是动态变化的。这种方法减少了内部碎片，但会产生外部碎片，即难以利用的小块空闲内存。")]),t._v(" "),a("h3",{attrs:{id:"非连续内存分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非连续内存分配"}},[t._v("#")]),t._v(" 非连续内存分配")]),t._v(" "),a("p",[t._v("为了解决连续内存分配的问题，人们提出了非连续内存分配技术，包括分页和分段。")]),t._v(" "),a("h4",{attrs:{id:"分页"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分页"}},[t._v("#")]),t._v(" 分页")]),t._v(" "),a("p",[t._v("分页将虚拟地址空间划分为固定大小的页（Page），将物理内存划分为同样大小的帧（Frame）。页表（Page Table）记录了页与帧之间的映射关系。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("虚拟地址 = 页号 + 页内偏移\n物理地址 = 帧号 + 页内偏移\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("分页的优点是消除了外部碎片，但会产生内部碎片。此外，页表可能会很大，需要额外的内存空间来存储。")]),t._v(" "),a("h4",{attrs:{id:"分段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分段"}},[t._v("#")]),t._v(" 分段")]),t._v(" "),a("p",[t._v("分段将程序的地址空间划分为多个不同长度的段（Segment），每个段有自己的名称和长度。段表（Segment Table）记录了段与物理内存之间的映射关系。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("虚拟地址 = 段号 + 段内偏移\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("分段的优点是符合程序的逻辑结构，便于共享和保护，但会产生外部碎片。")]),t._v(" "),a("h4",{attrs:{id:"段页式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#段页式"}},[t._v("#")]),t._v(" 段页式")]),t._v(" "),a("p",[t._v("段页式结合了分段和分页的优点，先将程序的地址空间划分为段，再将每个段划分为页。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("虚拟地址 = 段号 + 页号 + 页内偏移\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("段页式既保持了段式的逻辑结构，又利用了页式的高效内存管理，但地址转换过程更加复杂。")]),t._v(" "),a("h2",{attrs:{id:"虚拟内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[t._v("#")]),t._v(" 虚拟内存")]),t._v(" "),a("p",[t._v("虚拟内存是现代操作系统提供的一项重要功能，它允许程序使用比物理内存更大的地址空间。")]),t._v(" "),a("h3",{attrs:{id:"虚拟内存的基本思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存的基本思想"}},[t._v("#")]),t._v(" 虚拟内存的基本思想")]),t._v(" "),a("p",[t._v("虚拟内存的基本思想是将程序的地址空间与物理内存分开，程序可以使用虚拟地址，由操作系统负责将虚拟地址转换为物理地址。只有程序实际使用的部分才需要加载到物理内存中。")]),t._v(" "),a("h3",{attrs:{id:"虚拟内存的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存的实现"}},[t._v("#")]),t._v(" 虚拟内存的实现")]),t._v(" "),a("p",[t._v("虚拟内存通常通过请求分页（Demand Paging）来实现。初始时，只有程序的页表被加载到内存中，实际的数据页只有在被访问时才从磁盘加载到内存。")]),t._v(" "),a("h3",{attrs:{id:"页面置换算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页面置换算法"}},[t._v("#")]),t._v(" 页面置换算法")]),t._v(" "),a("p",[t._v("当内存不足时，操作系统需要选择一些页面换出到磁盘，为新的页面腾出空间。这就是页面置换算法要解决的问题。")]),t._v(" "),a("p",[t._v("常见的页面置换算法包括：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("最佳置换算法（OPT）")]),t._v("：选择未来最长时间不会被访问的页面进行置换。这是理论上的最优算法，但难以实现。")]),t._v(" "),a("li",[a("strong",[t._v("先进先出置换算法（FIFO）")]),t._v("：选择最早进入内存的页面进行置换。实现简单，但可能产生Belady异常。")]),t._v(" "),a("li",[a("strong",[t._v("最近未使用置换算法（NRU）")]),t._v("：根据页面的使用情况（R位和M位）选择置换的页面。")]),t._v(" "),a("li",[a("strong",[t._v("最近最少使用置换算法（LRU）")]),t._v("：选择最长时间未被访问的页面进行置换。性能较好，但实现开销大。")]),t._v(" "),a("li",[a("strong",[t._v("时钟置换算法（Clock）")]),t._v("：近似LRU算法，实现开销小。")])]),t._v(" "),a("h3",{attrs:{id:"抖动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抖动"}},[t._v("#")]),t._v(" 抖动")]),t._v(" "),a("p",[t._v("抖动（Thrashing）是指系统花费大量时间在页面置换上，而不是执行实际工作。当进程的缺页率非常高时，就会发生抖动。")]),t._v(" "),a("h2",{attrs:{id:"内存管理中的优化技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存管理中的优化技术"}},[t._v("#")]),t._v(" 内存管理中的优化技术")]),t._v(" "),a("h3",{attrs:{id:"缓存和预取"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存和预取"}},[t._v("#")]),t._v(" 缓存和预取")]),t._v(" "),a("p",[t._v("为了减少内存访问的延迟，现代系统采用了多级缓存机制。CPU缓存（L1、L2、L3）存储了最近访问的数据和指令，减少了访问主内存的次数。")]),t._v(" "),a("p",[t._v("预取技术则是在数据被访问之前，就将其加载到缓存或内存中，减少访问延迟。")]),t._v(" "),a("h3",{attrs:{id:"写回和写直达"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写回和写直达"}},[t._v("#")]),t._v(" 写回和写直达")]),t._v(" "),a("p",[t._v("在缓存和内存之间，有两种更新策略：写回（Write-back）和写直达（Write-through）。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("写回")]),t._v("：只有当缓存行被替换时，才将修改后的数据写回内存。")]),t._v(" "),a("li",[a("strong",[t._v("写直达")]),t._v("：每次修改缓存中的数据时，同时更新内存。")])]),t._v(" "),a("p",[t._v("写回减少了内存写入次数，但增加了缓存一致性维护的复杂性；写直达简化了缓存一致性，但增加了内存写入次数。")]),t._v(" "),a("h2",{attrs:{id:"内存分配算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存分配算法"}},[t._v("#")]),t._v(" 内存分配算法")]),t._v(" "),a("p",[t._v("在操作系统中，内存分配算法决定了如何为进程分配内存空间。常见的内存分配算法包括：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("首次适应算法（First Fit）")]),t._v("：从空闲链表头部开始，找到第一个足够大的空闲块进行分配。")]),t._v(" "),a("li",[a("strong",[t._v("最佳适应算法（Best Fit）")]),t._v("：选择能满足需求的最小空闲块进行分配。")]),t._v(" "),a("li",[a("strong",[t._v("最坏适应算法（Worst Fit）")]),t._v("：选择最大的空闲块进行分配。")]),t._v(" "),a("li",[a("strong",[t._v("下次适应算法（Next Fit）")]),t._v("：从上次分配的位置开始继续搜索。")])]),t._v(" "),a("h2",{attrs:{id:"内存保护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存保护"}},[t._v("#")]),t._v(" 内存保护")]),t._v(" "),a("p",[t._v("内存保护是操作系统的重要功能，确保每个进程只能访问自己的内存空间，防止恶意程序破坏其他进程或操作系统的数据。")]),t._v(" "),a("p",[t._v("常见的内存保护机制包括：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("基址-限长寄存器")]),t._v("：设置基址寄存器和限长寄存器，限制进程的访问范围。")]),t._v(" "),a("li",[a("strong",[t._v("页表中的保护位")]),t._v("：在页表中设置读、写、执行等权限位。")]),t._v(" "),a("li",[a("strong",[t._v("分段保护")]),t._v("：为每个段设置访问权限。")])]),t._v(" "),a("h2",{attrs:{id:"结语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[t._v("#")]),t._v(" 结语")]),t._v(" "),a("p",[t._v("内存管理是操作系统的核心功能之一，它为我们提供了抽象、保护、共享、虚拟化和高效的内存使用机制。从简单的连续分配到复杂的虚拟内存技术，内存管理经历了漫长的发展历程，为我们构建高效、可靠的计算机系统提供了坚实的基础。")]),t._v(" "),a("p",[t._v("了解内存管理不仅有助于我们更好地理解操作系统的工作原理，还能帮助我们编写更高效的程序。在未来的文章中，我们将继续探讨操作系统的其他重要主题。")]),t._v(" "),a("blockquote",[a("p",[t._v("内存管理就像是一位大管家，它精心安排每一块内存的使用，确保每个进程都能获得所需的资源，同时维护系统的稳定和安全。")])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("希望这篇文章能帮助你更好地理解操作系统的内存管理机制！如果你有任何问题或建议，欢迎在评论区留言讨论。😊")])])}),[],!1,null,null,null);a.default=_.exports}}]);